<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>LioLume Life Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&display=swap');
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;overflow:hidden;touch-action:none}
  body{background:#030810;color:#c8d8e8;font-family:'JetBrains Mono','Fira Code',monospace;display:flex;flex-direction:column;height:100dvh;-webkit-user-select:none;user-select:none}
  #header{padding:8px 12px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(100,140,180,0.12);background:rgba(8,16,32,0.9);flex-shrink:0;gap:6px}
  .logo{font-size:16px;font-weight:700;letter-spacing:2px;color:#5ae;white-space:nowrap}
  .hdr-left{display:flex;align-items:center;gap:6px;min-width:0}
  .count{font-size:9px;color:#4a6a8a;white-space:nowrap}
  .right{display:flex;gap:4px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .btn{padding:6px 8px;border-radius:6px;cursor:pointer;font-size:10px;letter-spacing:.5px;font-family:inherit;transition:all .15s;-webkit-tap-highlight-color:transparent;touch-action:manipulation;white-space:nowrap}
  .btn-spawn{background:rgba(80,170,240,0.2);border:1px solid rgba(80,170,240,0.35);color:#6be}
  .btn-spawn:active{background:rgba(80,170,240,0.4)}
  .btn-breed{background:rgba(180,80,240,0.2);border:1px solid rgba(180,80,240,0.35);color:#b8e;display:none}
  .btn-breed:active{background:rgba(180,80,240,0.4)}
  .btn-breed.show{display:inline-block}
  .btn-clear{background:rgba(240,80,80,0.12);border:1px solid rgba(240,80,80,0.25);color:#e88}
  .btn-clear:active{background:rgba(240,80,80,0.3)}
  .btn-sell{background:rgba(240,180,60,0.15);border:1px solid rgba(240,180,60,0.3);color:#ec6;display:none}
  .btn-sell:active{background:rgba(240,180,60,0.35)}
  .btn-sell.show{display:inline-block}
  .btn-grow{background:rgba(80,240,140,0.2);border:1px solid rgba(80,240,140,0.4);color:#6e8;font-size:10px;font-weight:600}
  .btn-codex{background:rgba(240,200,80,0.15);border:1px solid rgba(240,200,80,0.3);color:#ec8;font-size:10px}
  #status-bar{display:none;flex-shrink:0;padding:5px 12px;background:rgba(8,16,32,0.85);border-bottom:1px solid rgba(100,140,180,0.1);font-size:9px;color:#5a7a9a;text-align:center;letter-spacing:.5px;gap:8px;justify-content:center;align-items:center}
  #status-bar.show{display:flex}
  .status-chip{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:4px}
  .status-chip.p1{background:rgba(80,170,240,0.12);color:#6be;border:1px solid rgba(80,170,240,0.25)}
  .status-chip.p2{background:rgba(240,160,60,0.12);color:#eb8;border:1px solid rgba(240,160,60,0.25)}
  .dot{width:6px;height:6px;border-radius:50%}.dot.p1{background:#5ae}.dot.p2{background:#ea5}
  #tank-wrap{flex:1 1 auto;position:relative;overflow:hidden;background:#020810;min-height:0}
  #tank{position:absolute;top:0;left:0;width:100%;height:100%;display:block;touch-action:none}
  #hint{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);font-size:10px;color:#4a6a8a;letter-spacing:.5px;pointer-events:none;text-align:center;line-height:1.5;background:rgba(4,10,20,0.7);padding:6px 14px;border-radius:8px;border:1px solid rgba(60,90,120,0.15)}
  #drawer{position:fixed;bottom:0;left:0;right:0;background:rgba(6,12,24,0.97);border-top:1px solid rgba(100,140,180,0.15);border-radius:16px 16px 0 0;transform:translateY(100%);transition:transform .3s ease;max-height:75dvh;overflow:hidden;display:flex;flex-direction:column;z-index:10;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px)}
  #drawer.open{transform:translateY(0)}
  #drawer-handle{padding:8px;text-align:center;cursor:pointer;flex-shrink:0;-webkit-tap-highlight-color:transparent}
  #drawer-handle .bar{width:36px;height:4px;background:rgba(100,140,180,0.3);border-radius:2px;margin:0 auto 4px}
  #drawer-handle .label{font-size:8px;color:#5a7a9a;letter-spacing:1.5px}
  #drawer-content{padding:0 12px 14px;overflow-y:auto;flex:1;-webkit-overflow-scrolling:touch}
  .glabel{font-size:8px;color:#4a6a8a;letter-spacing:1.5px;margin-bottom:3px}
  #helix-canvas{display:block;border-radius:4px;background:rgba(8,16,28,0.4)}
  .trait-grid{display:grid;grid-template-columns:1fr 1fr 1fr 1fr 1fr 1fr;gap:6px 8px}
  .tcol h4{font-size:7px;letter-spacing:1.5px;margin-bottom:2px}
  .tcol.lume h4{color:#5ae}.tcol.lio h4{color:#ea5}.tcol.move h4{color:#a6e}.tcol.org h4{color:#6eb}.tcol.grow h4{color:#eb6}
  .trow{display:flex;justify-content:space-between;gap:3px;padding:1px 3px;border-radius:3px;cursor:default;font-size:8px;-webkit-tap-highlight-color:transparent}
  .trow.active{background:rgba(80,170,240,0.1)}
  .tcol.lio .trow.active{background:rgba(240,170,80,0.1)}
  .tcol.move .trow.active{background:rgba(160,100,230,0.1)}
  .tcol.org .trow.active{background:rgba(100,230,180,0.1)}
  .tcol.grow .trow.active{background:rgba(230,180,100,0.1)}
  .trow .tn{color:#7a9aba;white-space:nowrap}.tcol.lio .trow .tn{color:#ba9a6a}.tcol.move .trow .tn{color:#9a8aba}.tcol.org .trow .tn{color:#6aba9a}.tcol.grow .trow .tn{color:#ba9a6a}
  .trow .tv{font-weight:600;color:#c8dae8;white-space:nowrap}.tcol.lio .trow .tv{color:#e8dac8}.tcol.move .trow .tv{color:#d8c8e8}.tcol.org .trow .tv{color:#c8e8d8}.tcol.grow .trow .tv{color:#e8dac8}
  #bp-map{font-size:8px;color:#3a5a6a;line-height:1.4;margin-top:4px;grid-column:1/-1}
  #bp-map .ml{color:#5a7a9a;letter-spacing:1.5px;margin-bottom:2px}
  .sep{height:1px;background:rgba(100,140,180,0.08);margin:4px 0}
  .ptag{display:inline-block;padding:1px 5px;border-radius:8px;font-size:7px;letter-spacing:.5px;background:rgba(80,140,200,0.12);border:1px solid rgba(80,140,200,0.2);color:#7ab;white-space:nowrap}
  #codex-overlay{position:fixed;inset:0;background:rgba(4,10,20,0.95);z-index:1000;display:none;flex-direction:column;backdrop-filter:blur(8px)}
  #codex-overlay.open{display:flex}
  #codex-header{padding:12px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(100,140,180,0.15);flex-shrink:0}
  #codex-header h2{font-size:14px;color:#ec8;font-weight:600;letter-spacing:1px;margin:0}
  #codex-header .close-btn{background:none;border:1px solid rgba(240,100,100,0.3);color:#e88;padding:4px 10px;border-radius:4px;cursor:pointer;font-family:inherit;font-size:10px}
  #codex-body{flex:1;overflow-y:auto;padding:12px 16px;-webkit-overflow-scrolling:touch}
  .codex-empty{color:#4a6a8a;text-align:center;margin-top:40px;font-size:11px}
  .codex-card{background:rgba(15,28,45,0.6);border:1px solid rgba(80,130,180,0.15);border-radius:8px;padding:10px 12px;margin-bottom:8px}
  .codex-card .cc-prose{font-size:9px;color:#9bc;line-height:1.5;margin-bottom:6px}
  .codex-card .cc-tags{display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px}
  .codex-card .cc-meta{display:flex;justify-content:space-between;align-items:center}
  .codex-card .cc-stat{font-size:7px;color:#5a7a8a}
  .codex-card .cc-spawn{background:rgba(80,180,240,0.15);border:1px solid rgba(80,180,240,0.3);color:#6be;padding:4px 10px;border-radius:4px;cursor:pointer;font-family:inherit;font-size:9px;font-weight:600}
  .codex-card .cc-spawn:disabled{opacity:0.3;cursor:default}
  .codex-card .cc-new{display:inline-block;background:rgba(240,200,60,0.2);color:#ec8;font-size:6px;letter-spacing:1px;padding:1px 4px;border-radius:3px;margin-left:6px}
  .codex-card .cc-body{display:flex;gap:8px}
  .codex-card .cc-preview{width:90px;min-height:110px;flex-shrink:0;border-radius:6px;overflow:hidden;background:rgba(4,10,20,0.6)}
  .codex-card .cc-preview canvas{width:90px;height:110px;display:block}
  .codex-card .cc-detail{flex:1;min-width:0}
  .codex-card .cc-rename{background:none;border:1px solid rgba(120,160,200,0.2);color:#6a8aaa;padding:2px 6px;border-radius:3px;cursor:pointer;font-family:inherit;font-size:7px;margin-left:6px}
  .codex-card .cc-rename:hover{border-color:rgba(200,160,60,0.4);color:#ec8}
  .codex-card .cc-rels{margin-top:5px;padding-top:5px;border-top:1px solid rgba(80,130,180,0.1)}
  .codex-card .cc-rel-link{color:#6be;cursor:pointer;font-size:8px;text-decoration:underline;text-decoration-color:rgba(100,180,240,0.3)}
  .codex-card .cc-rel-link:hover{color:#ec8}
  .gen-tag{font-size:8px;color:#4a6a8a;margin-bottom:4px}
  @media(min-width:700px){
    #drawer{position:static;transform:none!important;transition:none;max-height:none;border-radius:0;border-top:none;border-left:1px solid rgba(100,140,180,0.12);width:310px;flex-shrink:0;display:flex;backdrop-filter:none}
    #drawer-handle{display:none}
    #main{display:flex;flex:1 1 auto;min-height:0;overflow:hidden}
    #tank-wrap{flex:1 1 auto;position:relative;min-width:0}
    .trow{font-size:9px}.trait-grid{gap:8px 12px}
  }
  @media(max-width:699px){#main{display:flex;flex-direction:column;flex:1 1 auto;min-height:0;position:relative}}
</style>
</head>
<body>
<div id="header">
  <div class="hdr-left"><span class="logo">LIOLUME</span><span class="count" id="cnt">0</span><span class="count" id="currency" style="color:#6be;margin-left:8px">â—¯ 0</span></div>
  <div class="right">
    <button class="btn btn-spawn" id="spawn-btn" onclick="spawn()">+ SPAWN (â—¯15)</button>
    <button class="btn btn-breed" id="breed-btn" onclick="breed()">âš­ BREED</button>
    <button class="btn btn-sell" id="sell-btn" onclick="sell()">âœ• SELL</button>
    <button class="btn btn-grow" id="grow-btn" onclick="startGrowZone()">âŒ˜ GROW (â—¯10)</button>
    <button class="btn btn-codex" id="codex-btn" onclick="toggleCodex()">ðŸ“– <span id="codex-count">0</span></button>
    <button class="btn" id="mute-btn" onclick="toggleMute()" style="background:rgba(140,120,200,0.15);border:1px solid rgba(140,120,200,0.3);color:#a8b">ðŸ”Š</button>
    <button class="btn btn-clear" onclick="clearAll()">CLEAR</button>
  </div>
</div>
<div id="status-bar"><span id="status-text"></span></div>
<div id="main">
  <div id="tank-wrap">
    <canvas id="tank"></canvas>
    <div id="hint">Tap to select Â· Tap another to pair Â· Hold+drag to move</div>
  </div>
  <div id="drawer">
    <div id="drawer-handle" onclick="toggleDrawer()"><div class="bar"></div><div class="label">GENOME INSPECTOR</div></div>
    <div id="drawer-content">
      <div class="gen-tag" id="sel-info"></div>
      <div class="glabel">GENOME â€” 52 BASE PAIRS</div>
      <canvas id="helix-canvas" style="width:100%;cursor:pointer;margin-bottom:6px"></canvas>
      <div class="sep"></div>
      <div id="phenotype" style="font-size:9px;color:#8ab;line-height:1.5;margin-bottom:4px;min-height:16px"></div>
      <div id="pheno-tags" style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px"></div>
      <div class="sep"></div>
      <div class="trait-grid" id="traits"></div>
    </div>
  </div>
</div>
<div id="codex-overlay">
  <div id="codex-header">
    <h2>ðŸ“– ENCYCLOPEDIA <span id="codex-total" style="font-weight:400;font-size:10px;color:#8a9a6a"></span></h2>
    <button class="close-btn" onclick="toggleCodex()">âœ• CLOSE</button>
  </div>
  <div id="codex-body"></div>
</div>
<script>
const BASES=["A","T","C","G"],COMP={"A":"T","T":"A","C":"G","G":"C"};
const BVAL={"A":0,"T":1,"C":2,"G":3};
const BCOL={"A":"#4ae88a","T":"#e84a6a","C":"#4a8ae8","G":"#e8c84a"};
const canvas=document.getElementById("tank");let ctx=canvas.getContext("2d");
let W=600,H=600,creatures=[],parent1Id=null,parent2Id=null,viewId=null,particles=[];
let bubbles=[],currency=0,floatTexts=[],hearts=[],growZones=[],placingGrow=false,growPreview=null;
let generation=0,drawerOpen=false,activeTrait=null,codexOpen=false;
const codex=new Map(); // species key â†’ {name, prose, tags, genome, count, firstSeen}
const BPC=52;
let dragId=null,dragOff={x:0,y:0},isDragging=false,dragStartTime=0,dragStartX=0,dragStartY=0;
let helixAngle=0,helixGenome=null,helixCreatureId=null,helixLitSet=null,helixHoverBP=-1;

// â”€â”€ Waveforms â”€â”€
function wSin(t){return Math.sin(t*Math.PI*2)}
function wTri(t){const v=((t%1)+1)%1;return v<.25?v*4:v<.75?2-v*4:v*4-4}
function wSaw(t){return 2*(((t%1)+1)%1)-1}
function wSqr(t){return((t%1)+1)%1<.5?1:-1}
function wBlend(t,wf){
  if(wf<.33){const m=wf/.33;return wSin(t)*(1-m)+wTri(t)*m}
  if(wf<.66){const m=(wf-.33)/.33;return wTri(t)*(1-m)+wSaw(t)*m}
  return wSaw(t)*(1-(wf-.66)/.34)+wSqr(t)*((wf-.66)/.34);
}
function wfN(v){if(v<.17)return"Sine";if(v<.5)return"Sinâ†’Tri";if(v<.56)return"Tri";if(v<.72)return"Triâ†’Saw";if(v<.78)return"Saw";return"Sawâ†’Sqr"}
function orgMixName(v){if(v<.25)return"Mandala";if(v<.5)return"Celtic";if(v<.75)return"Flower";return"Spiro"}
function voxTimbreName(v){if(v<.2)return"Pure";if(v<.4)return"Glass";if(v<.6)return"Bell";if(v<.8)return"Choir";return"Whistle"}
function fmtAge(a){const s=Math.floor(a);if(s<60)return s+"s";return Math.floor(s/60)+":"+(s%60<10?"0":"")+(s%60)}

const TRAITS={
  // LUME
  "Seeds":       {bp:[0,1,2],      cat:"lume", fmt:v=>v},
  "Hue":         {bp:[3,4,5],      cat:"lume", fmt:v=>v.toFixed(0)+"Â°"},
  "Hue 2":       {bp:[2,3],        cat:"lume", fmt:v=>v.toFixed(0)+"Â°"},
  "Tone Split":  {bp:[19,20],      cat:"lume", fmt:v=>v.toFixed(2)},
  "Saturation":  {bp:[4,5,6],      cat:"lume", fmt:v=>v.toFixed(0)+"%"},
  "Lightness":   {bp:[6,7],        cat:"lume", fmt:v=>v.toFixed(0)+"%"},
  "Glow":        {bp:[7,8,9],      cat:"lume", fmt:v=>v.toFixed(1)},
  "Min Reach":   {bp:[9,10],       cat:"lume", fmt:v=>v.toFixed(1)+"px"},
  "Max Reach":   {bp:[10,11,12],   cat:"lume", fmt:v=>v.toFixed(1)+"px"},
  "Curve Width": {bp:[11,12,13],   cat:"lume", fmt:v=>v.toFixed(2)},
  "Membrane":    {bp:[7,12,13],    cat:"lume", fmt:v=>v.toFixed(2)},
  "Stiffness":   {bp:[5,6,7],      cat:"lume", fmt:v=>v.toFixed(2)},
  "Scallop Lvl": {bp:[30,31],      cat:"lume", fmt:v=>v},
  "Scallop Amp": {bp:[31,32],      cat:"lume", fmt:v=>v.toFixed(2)},
  // MOVE
  "Pulse Str":   {bp:[14,15,16],   cat:"move", fmt:v=>v.toFixed(2)},
  "Pulse Rate":  {bp:[15,16,17],   cat:"move", fmt:v=>v.toFixed(2)+"s"},
  "Pulse Prob":  {bp:[13,17,18],   cat:"move", fmt:v=>(v*100).toFixed(0)+"%"},
  "Damping":     {bp:[18,19,20],   cat:"move", fmt:v=>v.toFixed(3)},
  // LIO
  "Trails":      {bp:[21,22,23],   cat:"lio",  fmt:v=>v},
  "Trail Nodes": {bp:[23,24,25],   cat:"lio",  fmt:v=>v+"Â±var"},
  "Trail Var":   {bp:[25,26],      cat:"lio",  fmt:v=>(v*100).toFixed(0)+"%"},
  "Seg Length":  {bp:[24,25,26],   cat:"lio",  fmt:v=>v.toFixed(1)+"px"},
  "Seg Var":     {bp:[26,27],      cat:"lio",  fmt:v=>(v*100).toFixed(0)+"%"},
  "Stretch":     {bp:[26,27],      cat:"lio",  fmt:v=>(v*100).toFixed(0)+"%"},
  "Thickness":   {bp:[31,32,33],   cat:"lio",  fmt:v=>v.toFixed(1)+"px"},
  "Taper":       {bp:[33,34],      cat:"lio",  fmt:v=>v.toFixed(2)},
  "Lio Gravity": {bp:[28,29,30],   cat:"lio",  fmt:v=>v.toFixed(1)},
  "Osc Amp":     {bp:[34,35,36],   cat:"lio",  fmt:v=>v.toFixed(1)},
  "Osc Freq":    {bp:[36,37],      cat:"lio",  fmt:v=>v.toFixed(2)},
  "Waveform":    {bp:[37,38],      cat:"lio",  fmt:v=>wfN(v)},
  "Osc Phase":   {bp:[38,39],      cat:"lio",  fmt:v=>v.toFixed(2)+"Ï€"},
  // ORGANELLES
  "Org Count":   {bp:[40,41],      cat:"org",  fmt:v=>v},
  "Org Size":    {bp:[41,42],      cat:"org",  fmt:v=>v.toFixed(2)},
  "Org Pulse":   {bp:[42,43],      cat:"org",  fmt:v=>v.toFixed(2)},
  "Org Drift":   {bp:[43,44],      cat:"org",  fmt:v=>v.toFixed(2)},
  "Org Hue":     {bp:[44,45],      cat:"org",  fmt:v=>v.toFixed(0)+"Â°"},
  "Org Mix":     {bp:[45,46,47],   cat:"org",  fmt:v=>orgMixName(v)},
  // GROWTH
  "Grow Rate":   {bp:[48,49],      cat:"grow", fmt:v=>v.toFixed(2)+"Ã—"},
  "Mature Age":  {bp:[49,50],      cat:"grow", fmt:v=>(v/60).toFixed(1)+"m"},
  "Birth Size":  {bp:[50,51],      cat:"grow", fmt:v=>(v*100).toFixed(0)+"%"},
  "Bloom Age":   {bp:[51,48],      cat:"grow", fmt:v=>(v*100).toFixed(0)+"%"},
  // VOICE
  "Pitch":       {bp:[14,36,37],   cat:"vox",  fmt:v=>v.toFixed(0)+"Hz"},
  "Timbre":      {bp:[37,38,39],   cat:"vox",  fmt:v=>voxTimbreName(v)},
  "Duration":    {bp:[15,16],      cat:"vox",  fmt:v=>(v*1000).toFixed(0)+"ms"},
  "Reverb":      {bp:[18,19],      cat:"vox",  fmt:v=>v.toFixed(2)+"s"},
  "Glide":       {bp:[34,35],      cat:"vox",  fmt:v=>(v>0?"+":"")+v.toFixed(0)+"Hz"},
  "Harmonics":   {bp:[40,44],      cat:"vox",  fmt:v=>v.toFixed(2)},
};

function rg(){return Array.from({length:BPC},()=>BASES[Math.floor(Math.random()*4)])}

// â”€â”€ Phenotype Summary â”€â”€
// Returns {tags:string[], prose:string} for quest matching and display
function phenotype(t){
  const tags=[];
  const parts=[];

  // SIZE (maxReach: 30..80)
  const szNorm=(t.maxReach-30)/50;
  if(szNorm<0.2){tags.push("tiny");parts.push("A tiny")}
  else if(szNorm<0.4){tags.push("small");parts.push("A small")}
  else if(szNorm<0.6){tags.push("medium");parts.push("A medium-sized")}
  else if(szNorm<0.8){tags.push("large");parts.push("A large")}
  else{tags.push("massive");parts.push("A massive")}

  // SHAPE (scallopLvl 0..3, scallopAmp 0.05..0.35)
  if(t.scallopLvl===0){tags.push("smooth");parts[0]+=" smooth"}
  else if(t.scallopLvl===1&&t.scallopAmp<0.15){tags.push("wavy");parts[0]+=" wavy"}
  else if(t.scallopLvl<=1){tags.push("scalloped");parts[0]+=" scalloped"}
  else if(t.scallopAmp>0.2){tags.push("jagged");parts[0]+=" jagged"}
  else{tags.push("ruffled");parts[0]+=" ruffled"}

  // HULL STIFFNESS (0.1..1.0)
  if(t.stiffness<0.3){tags.push("gelatinous");parts[0]+=" gelatinous"}
  else if(t.stiffness>0.7){tags.push("rigid");parts[0]+=" rigid"}

  // COLOR â€” hue name
  const hNames=[
    [15,"red"],[40,"orange"],[65,"gold"],[85,"yellow"],
    [150,"green"],[190,"teal"],[230,"blue"],[270,"indigo"],
    [310,"violet"],[340,"magenta"],[361,"crimson"]
  ];
  let hName="red";
  for(const[h,n]of hNames){if(t.hue<h){hName=n;break}}
  tags.push(hName);

  // Saturation descriptor (50..100)
  let colorDesc=hName;
  if(t.sat<62){tags.push("pale");colorDesc="pale "+hName}
  else if(t.sat>80){tags.push("vivid");colorDesc="vivid "+hName}

  // LIGHTNESS (40..70)
  if(t.lit<48){tags.push("dark");colorDesc="dark "+colorDesc}
  else if(t.lit>62){tags.push("bright");colorDesc="bright "+colorDesc}

  // Two-tone
  const hueDiff=Math.abs(t.hue-t.hue2);
  if(hueDiff>40&&hueDiff<320){
    let h2Name="red";
    for(const[h,n]of hNames){if(t.hue2<h){h2Name=n;break}}
    if(h2Name!==hName){tags.push("two-tone");colorDesc+="/"+h2Name}
  }

  parts[0]+=" "+colorDesc+" LioLume";

  // GLOW (8..38)
  if(t.glow<14){tags.push("dim");parts.push("with a faint glow")}
  else if(t.glow<22){tags.push("soft-glow");parts.push("with a soft glow")}
  else if(t.glow<30){tags.push("bright-glow");parts.push("with a bright aura")}
  else{tags.push("blazing");parts.push("with a blazing radiance")}

  // TENTACLES (trails: 1..6)
  if(t.trails<=2){tags.push("few-tentacles")}
  else if(t.trails<=4){tags.push("moderate-tentacles")}
  else{tags.push("many-tentacles")}
  const tDesc=t.trails===1?"a single tentacle":t.trails+" tentacles";

  // Trail length (segLen 8..28, nodes 4..7)
  const tLen=t.segLenBase*t.trailNodesBase;
  if(tLen<80){tags.push("short-tentacles");parts.push("bearing "+tDesc+" (short")}
  else if(tLen<160){tags.push("medium-tentacles");parts.push("bearing "+tDesc+" (mid-length")}
  else{tags.push("long-tentacles");parts.push("bearing "+tDesc+" (long")}

  // Trail thickness (2.5..10.5)
  if(t.thickness<4.5){tags.push("thin-tentacles");parts[parts.length-1]+=", thin)"}
  else if(t.thickness<7){parts[parts.length-1]+=")"}
  else{tags.push("thick-tentacles");parts[parts.length-1]+=", thick)"}

  // OSCILLATION (oscAmp 3..28)
  if(t.oscAmp>18){tags.push("undulating");parts.push("that undulate wildly")}
  else if(t.oscAmp>10){tags.push("swaying");parts.push("that sway gently")}

  // MOVEMENT (pulseStr 0.8..4.8, pulseRate 0.6..4.1)
  const speed=t.pulseStr/(t.pulseRate+0.1);
  if(speed<1){tags.push("sluggish")}
  else if(speed<2){tags.push("leisurely")}
  else if(speed<3.5){tags.push("active")}
  else{tags.push("hyperactive")}

  // ORGANELLES (count 3..12, type via orgMix)
  const oType=t.orgMix<0.25?"mandala":t.orgMix<0.5?"celtic":t.orgMix<0.75?"floral":"spiral";
  tags.push(oType+"-organelles");
  if(t.orgCount<=5){tags.push("few-organelles");parts.push("with sparse "+oType+" organelles")}
  else if(t.orgCount<=8){parts.push("with "+oType+" organelles")}
  else{tags.push("dense-organelles");parts.push("with dense "+oType+" organelles")}

  // Organelle size (0.3..1.0)
  if(t.orgSize>0.75){tags.push("large-organelles")}
  else if(t.orgSize<0.5){tags.push("tiny-organelles")}

  // MEMBRANE (0.2..0.7)
  if(t.membrane>0.5){tags.push("thick-membrane")}
  else if(t.membrane<0.3){tags.push("thin-membrane")}

  // GROWTH (matureAge 300..600)
  if(t.matureAge<380){tags.push("fast-grower")}
  else if(t.matureAge>520){tags.push("slow-grower")}

  // DAMPING (0.91..0.98) â€” how floaty
  if(t.damping>0.965){tags.push("floaty")}
  else if(t.damping<0.93){tags.push("snappy")}

  // VOICE (pitch 220..880, timbre 0..1)
  if(t.voxPitch<350){tags.push("deep-voice");parts.push("with a deep call")}
  else if(t.voxPitch<550){tags.push("mid-voice")}
  else if(t.voxPitch<700){tags.push("high-voice");parts.push("with a high chirp")}
  else{tags.push("soprano-voice");parts.push("with a piercing soprano")}

  if(t.voxTimbre<0.2){tags.push("pure-tone")}
  else if(t.voxTimbre>0.7){tags.push("rich-tone")}

  // Compile prose â€” first part is subject, rest joined with commas
  const prose=parts.join(", ")+".";

  return{tags,prose};
}

// Species key: combination of size + shape + color + organelle type
// Gives ~1000 possible species for meaningful variety
function speciesKey(tags){
  const pick=(opts)=>opts.find(o=>tags.includes(o))||"?";
  const sz=pick(["tiny","small","medium","large","massive"]);
  const sh=pick(["jagged","ruffled","scalloped","wavy","smooth"]);
  const co=pick(["red","orange","gold","yellow","green","teal","blue","indigo","violet","magenta","crimson"]);
  const og=pick(["mandala-organelles","celtic-organelles","floral-organelles","spiral-organelles"]);
  const gl=pick(["blazing","bright-glow","soft-glow","dim"]);
  return`${sz}|${sh}|${co}|${og.split("-")[0]}|${gl}`;
}

function discoverCreature(c){
  if(!c.phenotype) c.phenotype=phenotype(c.traits);
  const key=speciesKey(c.phenotype.tags);
  if(!codex.has(key)){
    codex.set(key,{
      name:autoName(key),
      prose:c.phenotype.prose,
      tags:[...c.phenotype.tags],
      genome:[...c.genome],
      count:1,
      firstSeen:Date.now(),
    });
    floatTexts.push({x:c.x,y:c.y-30,text:"NEW SPECIES!",age:0,hue:50});
    return true;
  }else{
    codex.get(key).count++;
    return false;
  }
}

function autoName(key){
  const p=key.split("|");
  const sizeGen={tiny:"Parvi",small:"Minor",medium:"Medi",large:"Magni",massive:"Titano"};
  const shapeGen={smooth:"globus",wavy:"undula",scalloped:"limba",jagged:"serra",ruffled:"crista"};
  const colorEpi={red:"rubr",orange:"aur",gold:"chrys",yellow:"flav",green:"virid",
    teal:"cyan",blue:"azur",indigo:"indic",violet:"viol",magenta:"ros",crimson:"carmin"};
  const orgSuf={mandala:"ala",celtic:"ica",floral:"osa",spiral:"ira"};
  const glowSub={blazing:"ignis","bright-glow":"lucis","soft-glow":"luma",dim:"umbra"};
  const genus=(sizeGen[p[0]]||"Xeno")+(shapeGen[p[1]]||"morpha");
  const species=(colorEpi[p[2]]||"xen")+(orgSuf[p[3]]||"ia");
  const sub=glowSub[p[4]]||"nox";
  return genus+" "+species+" "+sub;
}

function nm(g,...ix){return ix.reduce((s,i)=>s+BVAL[g[i]],0)/(ix.length*3)}

function decode(g){
  const minR=8+nm(g,9,10)*20;
  const maxRaw=20+nm(g,10,11,12)*45;
  const maxR=Math.max(maxRaw,minR+6);

  // Two-tone: hue2 offset from hue by 20-180Â°
  const hue1=nm(g,3,4,5)*360;
  const hueShift=20+nm(g,2,3)*160; // 20..180Â° offset

  return{
    seeds:      Math.floor(nm(g,0,1,2)*8)+4,
    hue:        hue1,
    hue2:       (hue1+hueShift)%360,
    toneSplit:  0.2+nm(g,19,20)*0.6, // 0.2..0.8 â€” where colors blend
    sat:        50+nm(g,4,5,6)*50,
    lit:        40+nm(g,6,7)*30,
    glow:       8+nm(g,7,8,9)*30,
    minReach:   minR,
    maxReach:   maxR,
    curveWidth: 0.15+nm(g,11,12,13)*1.4,
    membrane:   0.2+nm(g,7,12,13)*0.5,
    stiffness:  0.1+nm(g,5,6,7)*0.9,
    // Scalloping
    scallopLvl: Math.floor(nm(g,30,31)*2.5),  // 0..3 recursion depth
    scallopAmp: 0.05+nm(g,31,32)*0.18,        // 0.05..0.35 displacement fraction
    // Move
    pulseStr:   0.8+nm(g,14,15,16)*4.0,
    pulseRate:  0.6+nm(g,15,16,17)*3.5,
    pulseProb:  0.3+nm(g,13,17,18)*0.7,
    damping:    0.91+nm(g,18,19,20)*0.07,
    // Lio
    trails:     Math.floor(nm(g,21,22,23)*6)+1,
    trailNodesBase: Math.floor(nm(g,23,24,25)*4)+4, // 4..7 base
    trailNodesVar:  nm(g,25,26)*0.6,                 // 0..0.6 variance factor
    segLenBase:  8+nm(g,24,25,26)*20,                // 8..28 base
    segLenVar:   nm(g,26,27)*0.5,                     // 0..0.5 variance factor
    stretch:    0.03+nm(g,26,27)*0.18,
    thickness:  2.5+nm(g,31,32,33)*8.0,
    taper:      0.3+nm(g,33,34)*0.7,
    lioGravity: 30+nm(g,28,29,30)*120,
    oscAmp:     3+nm(g,34,35,36)*25,
    oscFreq:    0.5+nm(g,36,37)*3.5,
    waveform:   nm(g,37,38),
    oscPhOff:   nm(g,38,39)*2,
    // Organelles
    orgCount:   Math.floor(nm(g,40,41)*10)+3,   // 3..12
    orgSize:    0.3+nm(g,41,42)*0.7,             // 0.3..1.0 multiplier
    orgPulse:   0.1+nm(g,42,43)*0.9,             // 0.1..1.0 pulse reactivity
    orgDrift:   0.2+nm(g,43,44)*0.8,             // 0.2..1.0 drift speed
    orgHueShift:nm(g,44,45)*120,                 // 0..120Â° offset
    orgMix:     nm(g,45,46,47),                  // 0..1 type distribution
    // Growth
    growRate:    0.85+nm(g,48,49)*0.3,             // 0.85..1.15 maturity speed
    matureAge:  300+nm(g,49,50)*300,               // 300..600s (5-10 min)
    birthSize:  0.2+nm(g,50,51)*0.2,              // 0.2..0.4 starting scale
    bloomAge:   0.3+nm(g,51,48)*0.4,              // 0.3..0.7 fraction when shape emerges
    // Voice
    voxPitch:   220+nm(g,14,36,37)*660,            // 220..880 Hz (A3..A5)
    voxTimbre:  nm(g,37,38,39),                     // 0..1 harmonic character
    voxDur:     0.08+nm(g,15,16)*0.32,              // 0.08..0.40s
    voxReverb:  0.3+nm(g,18,19)*1.7,               // 0.3..2.0s decay
    voxGlide:   (nm(g,34,35)-0.5)*200,             // -100..+100 Hz pitch sweep
    voxHarmonics: 0.1+nm(g,40,44)*0.9,             // 0.1..1.0 overtone strength
  };
}

// Per-trail length parameters from genome â€” paired trails share same length for bilateral symmetry
function trailParams(t, genome, trailIdx, nTrails){
  // Compute pair index: center trail (if odd count) is unique, then pairs share index
  let pairIdx;
  const hasCenter=nTrails%2===1;
  if(hasCenter){
    if(trailIdx===0) pairIdx=0; // center gets its own
    else pairIdx=Math.floor((trailIdx-1)/2)+1; // pairs share: (1,2)â†’1, (3,4)â†’2, etc
  } else {
    pairIdx=Math.floor(trailIdx/2); // pairs share: (0,1)â†’0, (2,3)â†’1, etc
  }
  const g1=BVAL[genome[(pairIdx*11+5)%BPC]]/3;
  const g2=BVAL[genome[(pairIdx*7+13)%BPC]]/3;
  // Node count: base Â± variance (min 3, max 9)
  const nVar=(g1-0.5)*2*t.trailNodesVar;
  const nodes=Math.max(3, Math.min(9, Math.round(t.trailNodesBase+nVar*t.trailNodesBase)));
  // Segment length: base Â± variance (min 5)
  const sVar=(g2-0.5)*2*t.segLenVar;
  const segLen=Math.max(5, t.segLenBase+sVar*t.segLenBase);
  return{nodes, segLen};
}

function tvs(t){
  return{
    "Seeds":t.seeds,"Hue":t.hue,"Hue 2":t.hue2,"Tone Split":t.toneSplit,
    "Saturation":t.sat,
    "Lightness":t.lit,"Glow":t.glow,"Min Reach":t.minReach,"Max Reach":t.maxReach,
    "Curve Width":t.curveWidth,"Membrane":t.membrane,
    "Stiffness":t.stiffness,
    "Scallop Lvl":t.scallopLvl,"Scallop Amp":t.scallopAmp,
    "Pulse Str":t.pulseStr,"Pulse Rate":t.pulseRate,"Pulse Prob":t.pulseProb,"Damping":t.damping,
    "Trails":t.trails,"Trail Nodes":t.trailNodesBase,"Trail Var":t.trailNodesVar,
    "Seg Length":t.segLenBase,"Seg Var":t.segLenVar,"Stretch":t.stretch,
    "Thickness":t.thickness,"Taper":t.taper,"Lio Gravity":t.lioGravity,
    "Osc Amp":t.oscAmp,"Osc Freq":t.oscFreq,"Waveform":t.waveform,"Osc Phase":t.oscPhOff,
    "Org Count":t.orgCount,"Org Size":t.orgSize,"Org Pulse":t.orgPulse,
    "Org Drift":t.orgDrift,"Org Hue":t.orgHueShift,"Org Mix":t.orgMix,
    "Grow Rate":t.growRate,"Mature Age":t.matureAge,"Birth Size":t.birthSize,"Bloom Age":t.bloomAge,
    "Pitch":t.voxPitch,"Timbre":t.voxTimbre,"Duration":t.voxDur,"Reverb":t.voxReverb,"Glide":t.voxGlide,"Harmonics":t.voxHarmonics,
  };
}

function crossover(g1,g2){
  let a=Math.floor(Math.random()*(BPC-2))+1,b=Math.floor(Math.random()*(BPC-2))+1;
  if(a>b)[a,b]=[b,a];if(a===b)b=Math.min(b+1,BPC-1);
  const c1=[...g1],c2=[...g2];
  for(let i=a;i<=b;i++){c1[i]=g2[i];c2[i]=g1[i]}
  function mut(g){return g.map(b=>Math.random()<0.04?BASES[Math.floor(Math.random()*4)]:b)}
  return[mut(c1),mut(c2)];
}

// â”€â”€ Drawing helpers â”€â”€
function drawOpen(pts){
  const n=pts.length;if(n<2)return;
  if(n===2){ctx.moveTo(pts[0].x,pts[0].y);ctx.lineTo(pts[1].x,pts[1].y);return}
  // Catmull-Rom
  const pt=i=>i<0?pts[0]:i>=n?pts[n-1]:pts[i];
  ctx.moveTo(pts[0].x,pts[0].y);
  for(let i=0;i<n-1;i++){
    const p0=pt(i-1),p1=pt(i),p2=pt(i+1),p3=pt(i+2);
    const a=.5,d=(x,y)=>Math.pow(Math.hypot(y.x-x.x,y.y-x.y),a)||1e-6;
    const t1=d(p0,p1),t2=t1+d(p1,p2),t3=t2+d(p2,p3);
    const c1x=p1.x+(p2.x-p0.x)/t2*(t2-t1)/3,c1y=p1.y+(p2.y-p0.y)/t2*(t2-t1)/3;
    const c2x=p2.x-(p3.x-p1.x)/(t3-t1)*(t2-t1)/3,c2y=p2.y-(p3.y-p1.y)/(t3-t1)*(t2-t1)/3;
    ctx.bezierCurveTo(c1x,c1y,c2x,c2y,p2.x,p2.y);
  }
}

// â”€â”€ Build Lume shape: scatter DNA seeds on right half, mirror for perfect bilateral symmetry â”€â”€

// Build STATIC right-side profile once â€” cached on creature
// Returns {profile: [{x,y,r,angle}...], topY, botY}
// Profile is ordered: top anchor â†’ seeds sorted top-to-bottom â†’ bottom anchor
function buildStaticHull(t, genome){
  const nSeeds=t.seeds;
  const minR=t.minReach, maxR=t.maxReach;

  // Generate seed points on RIGHT side (x > 0) from genome
  const rightPts=[];
  for(let i=0;i<nSeeds;i++){
    const gx1=BVAL[genome[(i*7)%BPC]]/3;
    const gx2=BVAL[genome[(i*7+3)%BPC]]/3;
    const gy1=BVAL[genome[(i*5+1)%BPC]]/3;
    const gy2=BVAL[genome[(i*5+11)%BPC]]/3;
    const gy3=BVAL[genome[(i*3+17)%BPC]]/3;

    const x=minR*0.1+(gx1*0.5+gx2*0.5)*(maxR*0.95-minR*0.1);
    const yBlend=gy1*0.4+gy2*0.35+gy3*0.25;
    const y=(yBlend-0.5)*maxR*1.8;
    rightPts.push({x:Math.max(0.5,x), y});
  }

  // Find vertical extent for anchors
  let seedMinY=Infinity, seedMaxY=-Infinity;
  for(const p of rightPts){
    if(p.y<seedMinY) seedMinY=p.y;
    if(p.y>seedMaxY) seedMaxY=p.y;
  }
  const topY=seedMinY-maxR*0.15;
  const botY=seedMaxY+maxR*0.1;

  // Sort right seeds by angle from top-center going clockwise
  // (angle measured from -Y axis, so top = smallest angle)
  rightPts.sort((a,b)=>{
    const aa=Math.atan2(a.x,-(a.y-topY));
    const ab=Math.atan2(b.x,-(b.y-topY));
    return aa-ab;
  });

  // Dedup close neighbors
  const cleaned=[rightPts[0]];
  for(let i=1;i<rightPts.length;i++){
    const prev=cleaned[cleaned.length-1];
    if(Math.hypot(rightPts[i].x-prev.x,rightPts[i].y-prev.y)>1.5){
      cleaned.push(rightPts[i]);
    }
  }

  // Build profile: top anchor â†’ right seeds â†’ bottom anchor
  const profile=[
    {x:0, y:topY},
    ...cleaned,
    {x:0, y:botY}
  ].map(p=>({
    x:p.x, y:p.y,
    angle:Math.atan2(p.y,p.x),
    r:Math.hypot(p.x,p.y)
  }));

  // Store seed positions for inner organelle rendering (right side only, will be mirrored)
  profile.seeds=cleaned.map(p=>({x:p.x, y:p.y}));

  return profile; // right-side profile only
}

// Apply jelly wobble to right profile, then mirror to produce full symmetric hull
function buildLumeShape(t, profile, phase){
  const softness=(1.0-t.stiffness);
  const nProf=profile.length;

  // Wobble right-side profile
  const rightWobbled=profile.map((nd,i)=>{
    const frac=i/(nProf-1); // 0=top, 1=bottom â€” used for symmetric wave indexing
    const r=nd.r, a=nd.angle;
    // Radial breathing: uses frac (not i) so mirrors get same displacement
    const breath=Math.sin(phase*0.7+frac*Math.PI*2)*softness*4.5
                +Math.sin(phase*1.4-frac*Math.PI*3+0.4)*softness*3.0
                +Math.sin(phase*2.3+frac*Math.PI*1.5)*softness*1.8
                +Math.sin(phase*0.4+frac*Math.PI*0.5)*softness*2.0;
    // Tangential ripple: perpendicular to radius, same magnitude for mirrors
    const ripple=Math.sin(phase*1.2+frac*Math.PI*4)*softness*3.5
                +Math.cos(phase*0.6-frac*Math.PI*2.5)*softness*2.5
                +Math.sin(phase*1.9+frac*Math.PI*5)*softness*1.5;
    const newR=r+breath;
    const nx=-Math.sin(a), ny=Math.cos(a);
    return{
      x:Math.cos(a)*newR+nx*ripple,
      y:Math.sin(a)*newR+ny*ripple,
      r:newR, angle:a, frac
    };
  });

  // Build full hull: right side â†’ reverse-mirrored left side
  // Skip first (top anchor) and last (bottom anchor) from mirror to avoid duplicates
  const hull=[];

  // Right side: top anchor through seeds to bottom anchor
  for(const p of rightWobbled){
    hull.push({x:p.x, y:p.y, r:p.r, angle:p.angle});
  }

  // Left side: mirror of right, reversed (bottom anchor already placed, skip it;
  // walk from second-to-last back to index 1, mirroring x)
  for(let i=nProf-2;i>=1;i--){
    const p=rightWobbled[i];
    hull.push({x:-p.x, y:p.y, r:p.r, angle:Math.PI-p.angle});
  }

  return hull;
}

// â”€â”€ Organelle generation â”€â”€
// Types: 0=mandala (radial petals+rings), 1=celtic knot (interwoven loops),
//        2=sacred geometry (flower of life), 3=spirograph (hypotrochoid curves)
function generateOrganelles(t,genome){
  const orgs=[];
  const count=t.orgCount;
  const mix=t.orgMix;
  // Distribute types based on mix value
  for(let i=0;i<count;i++){
    // Hash from genome + index for deterministic placement
    const h1=BVAL[genome[(i*13+7)%BPC]]/3;
    const h2=BVAL[genome[(i*11+3)%BPC]]/3;
    const h3=BVAL[genome[(i*7+17)%BPC]]/3;
    const h4=BVAL[genome[(i*9+23)%BPC]]/3;
    // Type: blend between types based on mix + per-organelle hash
    const typeVal=(mix+h3*0.4)%1;
    let type;
    if(typeVal<0.28) type=0; // mandala
    else if(typeVal<0.55) type=1; // celtic knot
    else if(typeVal<0.8) type=2; // sacred geometry
    else type=3; // spirograph
    // Position: scattered within hull using genome-derived coords
    // Use polar coords relative to hull center, constrained to inner 70%
    const angle=h1*Math.PI*2+i*2.399; // golden angle spacing
    const rFrac=0.2+h2*0.5; // 20-70% of hull radius
    // Size variation per organelle
    const sizeVar=0.6+h4*0.8; // 0.6..1.4
    orgs.push({
      type, angle, rFrac, sizeVar,
      phaseOff:h1*Math.PI*2+h2*Math.PI, // unique phase
      driftOff:h3*Math.PI*2, // drift phase offset
      elongation:type===2?1.5+h4:1, // mito are elongated
      elongAngle:h2*Math.PI, // elongation direction
    });
  }
  return orgs;
}

// â”€â”€ Verlet â”€â”€
function vpt(x,y){return{x,y,px:x,py:y}}
function constrainChain(pts,segLen,maxStretch,iters){
  const maxL=segLen*(1+maxStretch),minL=segLen*(1-maxStretch*.3);
  for(let it=0;it<iters;it++){
    for(let i=0;i<pts.length-1;i++){
      const a=pts[i],b=pts[i+1];
      const dx=b.x-a.x,dy=b.y-a.y,dist=Math.hypot(dx,dy)||.001;
      if(dist>maxL||dist<minL){
        const target=dist>maxL?maxL:minL;
        const diff=(dist-target)/dist;
        const ox=dx*diff*.5,oy=dy*diff*.5;
        const bias=i===0?.9:.5;
        a.x+=ox*bias;a.y+=oy*bias;b.x-=ox*(1-bias);b.y-=oy*(1-bias);
      }
    }
  }
}

// â”€â”€ Creature â”€â”€
function createCreature(x,y,genome){
  if(!genome)genome=rg();
  // Extend short genomes (backward compat)
  while(genome.length<BPC) genome.push(BASES[Math.floor(Math.random()*4)]);
  const t=decode(genome),trails=[];
  const nT=t.trails;

  // Build static right-side profile and cache it
  const staticHull=buildStaticHull(t,genome);
  const nProf=staticHull.length; // profile length (right side only)

  // Build full hull at rest (phase=0) for attachment computation
  const fullHull=buildLumeShape(t,staticHull,0);
  const hN=fullHull.length; // full hull = 2*nProf - 2

  // Bottom anchor is at profile index nProf-1 (last element)
  // In full hull, this is also at index nProf-1
  const botIdx=nProf-1;
  const botPt=fullHull[botIdx]; // should be at xâ‰ˆ0

  // Build right-side bottom arc: walk backward from botIdx through right-side profile
  // Profile goes top(0) â†’ seeds â†’ bottom(nProf-1), so bottom arc is near the end
  const rightArc=[{x:botPt.x, y:botPt.y, d:0, hi:botIdx}];
  let rDist=0;
  for(let k=botIdx-1;k>=1;k--){
    const prev=rightArc[rightArc.length-1];
    const nd=fullHull[k];
    rDist+=Math.hypot(nd.x-prev.x,nd.y-prev.y);
    // Stop when we've gone past the widest part (seeds curving up)
    if(nd.y<botPt.y-Math.abs(botPt.y)*0.8-t.maxReach*0.3) break;
    rightArc.push({x:nd.x, y:nd.y, d:rDist, hi:k});
  }

  // Build left-side bottom arc: walk forward from botIdx through left side of hull
  const leftArc=[{x:botPt.x, y:botPt.y, d:0, hi:botIdx}];
  let lDist=0;
  for(let k=botIdx+1;k<hN;k++){
    const prev=leftArc[leftArc.length-1];
    const nd=fullHull[k];
    lDist+=Math.hypot(nd.x-prev.x,nd.y-prev.y);
    if(nd.y<botPt.y-Math.abs(botPt.y)*0.8-t.maxReach*0.3) break;
    leftArc.push({x:nd.x, y:nd.y, d:lDist, hi:k});
  }

  // Interpolate along arc, returning {x,y,hi,ht} for hull tracking
  function interpArc(arc,d){
    if(d<=0) return{x:arc[0].x,y:arc[0].y,hi:arc[0].hi,ht:0};
    for(let i=1;i<arc.length;i++){
      if(arc[i].d>=d){
        const t2=(d-arc[i-1].d)/(arc[i].d-arc[i-1].d||1);
        return{
          x:arc[i-1].x+(arc[i].x-arc[i-1].x)*t2,
          y:arc[i-1].y+(arc[i].y-arc[i-1].y)*t2,
          hi:arc[i-1].hi, ht:0 // snap to nearest hull vertex for tracking
        };
      }
    }
    const last=arc[arc.length-1];
    return{x:last.x,y:last.y,hi:last.hi,ht:0};
  }

  // Find closest hull edge for a point
  function findHullEdge(px,py){
    let bestIdx=0,bestT=0,bestD=Infinity;
    for(let e=0;e<hN;e++){
      const a2=fullHull[e],b2=fullHull[(e+1)%hN];
      const ex=b2.x-a2.x,ey=b2.y-a2.y;
      const el=ex*ex+ey*ey||1;
      const t2=Math.max(0,Math.min(1,((px-a2.x)*ex+(py-a2.y)*ey)/el));
      const qx=a2.x+ex*t2,qy=a2.y+ey*t2;
      const d=Math.hypot(px-qx,py-qy);
      if(d<bestD){bestD=d;bestIdx=e;bestT=t2}
    }
    return{hi:bestIdx,ht:bestT};
  }

  // Place trails: symmetric pairs + center for odd
  const attachPts=[];
  const arcLen=Math.min(rDist,lDist)||10;

  if(nT===1){
    attachPts.push({lx:botPt.x, ly:botPt.y, ...findHullEdge(botPt.x,botPt.y)});
  } else {
    const hasCenter=nT%2===1;
    const nPairs=Math.floor(nT/2);
    if(hasCenter){
      attachPts.push({lx:botPt.x, ly:botPt.y, ...findHullEdge(botPt.x,botPt.y)});
    }
    for(let p=0;p<nPairs;p++){
      const frac=nPairs===1?0.5:0.15+(p/(nPairs-1))*0.7;
      const d=frac*arcLen;
      const rp=interpArc(rightArc,d);
      const lp=interpArc(leftArc,d);
      const rEdge=findHullEdge(rp.x,rp.y);
      const lEdge=findHullEdge(lp.x,lp.y);
      attachPts.push({lx:rp.x, ly:rp.y, ...rEdge});
      attachPts.push({lx:lp.x, ly:lp.y, ...lEdge});
    }
  }

  for(let i=0;i<nT;i++){
    const ap=attachPts[i];
    const tp=trailParams(t, genome, i, nT);
    const pts=[];
    for(let j=0;j<tp.nodes;j++){
      const px=x+ap.lx;
      const py=y+ap.ly+j*tp.segLen;
      pts.push(vpt(px,py));
    }
    trails.push({lx:ap.lx, ly:ap.ly, hullIdx:ap.hi, hullT:ap.ht, segLen:tp.segLen, trailGroup:i, points:pts});
  }
  const organelles=generateOrganelles(t,genome);
  return{
    id:Date.now()+Math.random(),genome,traits:t,staticHull,x,y,gen:generation,
    vx:0,vy:0,lean:0,birthFlash:1.0,age:0,
    squishX:0,squishY:0,
    wanderAngle:Math.random()*Math.PI*2,
    pulseTimer:Math.random()*t.pulseRate,pulseVisual:0,
    phase:Math.random()*Math.PI*2,trails,organelles,
    time:Math.random()*100,bubbleTimer:Math.random()*5,voxTimer:Math.random()*10,
  };
}

function updateCreature(c,dt){
  const isDrag=c.id===dragId;
  const t=c.traits;
  c.time+=dt;c.phase+=dt*1.5;
  c.age+=dt*t.growRate*growZoneMultiplier(c.x,c.y);
  // First creature matures in 30s; normal creatures 5-10 min (from genes)
  const effMature=c.isFirst?30:t.matureAge;
  const rawMat=Math.min(c.age/effMature,1);
  c.maturity=rawMat*rawMat*(3-2*rawMat); // smoothstep
  // Discover species on first maturity
  if(c.maturity>=0.95&&!c.discovered){c.discovered=true;discoverCreature(c)}
  c.pulseVisual*=.90;if(c.pulseVisual<.01)c.pulseVisual=0;
  if(c.birthFlash>0)c.birthFlash*=0.97;if(c.birthFlash<.01)c.birthFlash=0;
  // Decay squish from collisions
  c.squishX*=0.85;c.squishY*=0.85;
  if(Math.abs(c.squishX)<0.01)c.squishX=0;
  if(Math.abs(c.squishY)<0.01)c.squishY=0;
  // Clamp squish magnitude
  const sqM=Math.hypot(c.squishX,c.squishY);
  if(sqM>0.5){c.squishX*=0.5/sqM;c.squishY*=0.5/sqM}

  if(!isDrag){
    c.pulseTimer-=dt;
    if(c.pulseTimer<=0){
      c.pulseTimer=t.pulseRate*(.8+Math.random()*.4);
      if(Math.random()<t.pulseProb){
        c.vx+=Math.cos(c.wanderAngle)*t.pulseStr;
        c.vy+=Math.sin(c.wanderAngle)*t.pulseStr;
        c.pulseVisual=1.0;
      }
    }
    c.vx*=t.damping;c.vy*=t.damping;
    // Extra quadratic drag: faster creatures slow down faster
    const spd=Math.hypot(c.vx,c.vy);
    if(spd>0.1){
      const drag=0.015*spd; // quadratic drag coefficient
      const scale=Math.max(0,(spd-drag)/spd);
      c.vx*=scale;c.vy*=scale;
    }
    c.wanderAngle+=Math.sin(c.time*.3)*.02;
    // Ambient current: very gentle, doesn't override pulse dynamics
    const driftX=Math.sin(c.time*0.15+c.id*3.7)*0.02;
    const driftY=Math.cos(c.time*0.12+c.id*2.3)*0.015;
    c.vx+=driftX;c.vy+=driftY;
    // Boundary enforcement: soft repulsion at margin, hard reflect + clamp at edge
    const margin=60, edge=15, maxR=t.maxReach;
    const pad=edge+maxR*0.5;
    const bottomPad=H*0.13+maxR*0.5; // keep above substrate (starts at 88%)
    // Soft steering zone
    if(c.x<margin+pad){const f=1-Math.max(0,(c.x-pad)/(margin));c.vx+=f*0.6;c.wanderAngle=Math.random()*.6-.3}
    if(c.x>W-margin-pad){const f=1-Math.max(0,(W-pad-c.x)/(margin));c.vx-=f*0.6;c.wanderAngle=Math.PI+Math.random()*.6-.3}
    if(c.y<margin+pad){const f=1-Math.max(0,(c.y-pad)/(margin));c.vy+=f*0.6;c.wanderAngle=Math.PI*.5+Math.random()*.6-.3}
    if(c.y>H-margin-bottomPad){const f=1-Math.max(0,(H-bottomPad-c.y)/(margin));c.vy-=f*0.6;c.wanderAngle=-Math.PI*.5+Math.random()*.6-.3}
    c.x+=c.vx;c.y+=c.vy;
    // Hard clamp + velocity kill at edge
    if(c.x<pad){c.x=pad;if(c.vx<0)c.vx*=-0.3}
    if(c.x>W-pad){c.x=W-pad;if(c.vx>0)c.vx*=-0.3}
    if(c.y<pad){c.y=pad;if(c.vy<0)c.vy*=-0.3}
    if(c.y>H-bottomPad){c.y=H-bottomPad;if(c.vy>0)c.vy*=-0.3}
  }
  // Lean: blend velocity direction + trail pendulum
  const speed=Math.hypot(c.vx,c.vy);
  // Velocity lean: tilt forward into movement direction
  const velLean=speed>0.15?Math.atan2(c.vx,1.0)*0.5*Math.min(speed/3,1):0;

  // Trail pendulum lean (lighter contribution)
  const cosL=Math.cos(-c.lean),sinL=Math.sin(-c.lean);
  let trailCX=0,trailW=0;
  for(const trail of c.trails){
    for(let i=1;i<trail.points.length;i++){
      const w=i;
      const dx=trail.points[i].x-c.x;
      trailCX+=(dx*cosL)*w;
      trailW+=w;
    }
  }
  if(trailW>0)trailCX/=trailW;
  const trailLean=Math.atan2(trailCX,t.maxReach*0.5+10)*0.4;

  // Blend: velocity dominant when moving, trail dominant when still
  const velWeight=Math.min(speed/2,1);
  const maxLean=0.8;
  const targetLean=velLean*velWeight+trailLean*(1-velWeight*0.6);
  c.lean+=(Math.max(-maxLean,Math.min(maxLean,targetLean))-c.lean)*0.1;
  // Bubble emission â€” adults only
  if((c.maturity||0)>=0.95){
    c.bubbleTimer-=dt;
    if(c.bubbleTimer<=0){
      emitBubble(c);
      c.bubbleTimer=3+Math.random()*5; // every 3-8s
    }
    // Vocalization â€” 4Ã— less frequent than pulse
    c.voxTimer-=dt;
    if(c.voxTimer<=0){
      c.voxTimer=t.pulseRate*4*(.7+Math.random()*.6);
      if(Math.random()<t.pulseProb*0.6) voxCall(c);
    }
  }
  updateTrails(c,dt);
}

function updateTrails(c,dt){
  const t=c.traits;
  const mat=c.maturity||0;
  // Trails invisible below 15% maturity, nubs until ~50%
  const trailMat=Math.max((mat-0.05)/0.95,0); // visible from 5%
  if(trailMat<0.001) return;
  // Length stays stubby until late â€” cubic ease-in
  const trailLen=trailMat*trailMat*trailMat; // 50% mat â†’ only 12.5% length

  const growScale=t.birthSize+(1-t.birthSize)*mat;
  const grav=t.lioGravity,dtSq=dt*dt;
  const cosA=Math.cos(c.lean),sinA=Math.sin(c.lean);
  const ps=(1-c.pulseVisual*.12)*growScale; // pulse scale Ã— growth scale

  // Compute wobbled hull for attachment tracking
  const wHull=buildLumeShape(t,c.staticHull,c.phase);
  const hN=wHull.length;

  for(let ti=0;ti<c.trails.length;ti++){
    const trail=c.trails[ti],pts=trail.points;
    // Interpolate wobbled hull edge to get live attachment position
    const hi=trail.hullIdx%hN, ht=trail.hullT;
    const a=wHull[hi], b=wHull[(hi+1)%hN];
    const lx=(a.x+(b.x-a.x)*ht)*ps;
    const ly=(a.y+(b.y-a.y)*ht)*ps;
    // Transform to world space via lean rotation
    const wx=c.x+lx*cosA-ly*sinA;
    const wy=c.y+lx*sinA+ly*cosA;
    pts[0].x=wx;pts[0].y=wy;pts[0].px=wx;pts[0].py=wy;
    for(let i=1;i<pts.length;i++){
      const p=pts[i];const vx=(p.x-p.px)*.96,vy=(p.y-p.py)*.96;
      p.px=p.x;p.py=p.y;p.x+=vx;p.y+=vy;p.y+=grav*dtSq*2.5;
      const frac=i/pts.length;
      const wT=frac*t.oscFreq+c.time*t.oscFreq*0.4+ti*t.oscPhOff*Math.PI+c.phase*0.7;
      const oscF=wBlend(wT,t.waveform)*t.oscAmp*frac*dtSq*30;
      const dx=p.x-pts[i-1].x,dy=p.y-pts[i-1].y,len=Math.hypot(dx,dy)||1;
      p.x+=(-dy/len)*oscF;p.y+=(dx/len)*oscF;
    }
    constrainChain(pts,trail.segLen*trailLen,t.stretch,8);

    // Floor collision â€” keep trail nodes above substrate
    const floorY=H*0.88-5;
    for(let i=1;i<pts.length;i++){
      if(pts[i].y>floorY){
        pts[i].y=floorY;
        pts[i].py=pts[i].y; // kill downward velocity
      }
    }
  }
}

// â”€â”€ Soft body collisions â”€â”€
function softCollide(a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  const dist=Math.hypot(dx,dy)||0.01;

  // Collision radius: use average of hull extents for each creature
  const gA=a.traits.birthSize+(1-a.traits.birthSize)*(a.maturity||0);
  const gB=b.traits.birthSize+(1-b.traits.birthSize)*(b.maturity||0);
  const rA=a.traits.maxReach*0.7*gA;
  const rB=b.traits.maxReach*0.7*gB;
  const minDist=rA+rB;

  if(dist>=minDist) return; // no overlap

  // Penetration depth
  const overlap=minDist-dist;
  const nx=dx/dist, ny=dy/dist; // normal from A to B

  // Soft spring force â€” proportional to overlap, not instant separation
  const stiffness=0.25; // soft, not rigid
  const force=overlap*stiffness;

  // Mass proportional to size (heavier creatures move less)
  const mA=rA*rA, mB=rB*rB;
  const totalM=mA+mB||1;
  const ratioA=mB/totalM; // lighter creature gets pushed more
  const ratioB=mA/totalM;

  // Don't push dragged creatures
  const aFixed=a.id===dragId;
  const bFixed=b.id===dragId;

  if(!aFixed){
    a.x-=nx*force*ratioA;
    a.y-=ny*force*ratioA;
    // Add gentle velocity deflection
    a.vx-=nx*force*ratioA*0.15;
    a.vy-=ny*force*ratioA*0.15;
  }
  if(!bFixed){
    b.x+=nx*force*ratioB;
    b.y+=ny*force*ratioB;
    b.vx+=nx*force*ratioB*0.15;
    b.vy+=ny*force*ratioB*0.15;
  }

  // If one is fixed (dragged), the other takes full push
  if(aFixed&&!bFixed){
    b.x+=nx*force*0.5;
    b.y+=ny*force*0.5;
  }
  if(bFixed&&!aFixed){
    a.x-=nx*force*0.5;
    a.y-=ny*force*0.5;
  }

  // Accumulate squish vector for visual deformation
  const squishMag=overlap/(minDist)*0.3; // 0..0.3 normalized
  if(!aFixed){
    a.squishX+=nx*squishMag;
    a.squishY+=ny*squishMag;
  }
  if(!bFixed){
    b.squishX-=nx*squishMag;
    b.squishY-=ny*squishMag;
  }
}

// â”€â”€ Draw Lio trail â”€â”€
function drawLioTrail(pts,hue1,hue2,sat,lit,glow,baseW,taper){
  if(pts.length<2)return;
  ctx.save();
  ctx.shadowColor=`hsla(${hue1},${sat}%,${Math.min(lit+20,85)}%,0.5)`;
  ctx.shadowBlur=glow*.3;

  // Draw thin segments between nodes (butt caps = no overlap)
  ctx.lineCap='butt';ctx.lineJoin='miter';
  for(let i=0;i<pts.length-1;i++){
    const frac=i/(pts.length-1);
    const w=baseW*(1-frac*taper)*0.45;
    if(w<.1)break;
    const alpha=Math.max(.6*(1-frac*.85),.02);
    const h=frac<0.4?hue1:hue1+(hue2-hue1)*((frac-0.4)/0.6);
    ctx.beginPath();
    ctx.moveTo(pts[i].x,pts[i].y);
    ctx.lineTo(pts[i+1].x,pts[i+1].y);
    ctx.strokeStyle=`hsla(${h},${sat}%,${Math.min(lit+10,80)}%,${alpha})`;
    ctx.lineWidth=w;ctx.stroke();
  }

  // Draw joint nodes as circles â€” color shifts along length
  for(let i=0;i<pts.length;i++){
    const frac=i/(pts.length-1);
    const r=baseW*(1-frac*taper)*0.38;
    if(r<.2)break;
    const alpha=Math.max(.75*(1-frac*.8),.04);
    const h=frac<0.4?hue1:hue1+(hue2-hue1)*((frac-0.4)/0.6);
    ctx.beginPath();ctx.arc(pts[i].x,pts[i].y,r,0,Math.PI*2);
    ctx.fillStyle=`hsla(${h},${sat}%,${Math.min(lit+15,85)}%,${alpha})`;
    ctx.fill();
    ctx.beginPath();ctx.arc(pts[i].x,pts[i].y,r,0,Math.PI*2);
    ctx.strokeStyle=`hsla(${h},${sat}%,${Math.min(lit+30,93)}%,${alpha*0.5})`;
    ctx.lineWidth=0.6;ctx.stroke();
  }

  // Core highlight line
  ctx.shadowBlur=glow*.1;
  const gr=ctx.createLinearGradient(pts[0].x,pts[0].y,pts[pts.length-1].x,pts[pts.length-1].y);
  gr.addColorStop(0,`hsla(${hue1},${Math.max(sat-20,30)}%,${Math.min(lit+32,93)}%,0.35)`);
  gr.addColorStop(.4,`hsla(${hue2},${sat}%,${Math.min(lit+20,85)}%,0.08)`);
  gr.addColorStop(1,`hsla(${hue2},${sat}%,${lit}%,0)`);
  ctx.strokeStyle=gr;ctx.lineWidth=Math.max(baseW*.12,.3);ctx.lineCap='round';
  ctx.beginPath();drawOpen(pts);ctx.stroke();
  ctx.restore();
}

// â”€â”€ Draw Lume (kaleidoscope) â”€â”€

// Recursive scallop: subdivide midpoints outward
function scallopEdge(ax,ay,bx,by,depth,amp,outX,outY){
  if(depth<=0){return[{x:bx,y:by}]}
  const mx=(ax+bx)/2, my=(ay+by)/2;
  const dx=bx-ax, dy=by-ay;
  const len=Math.hypot(dx,dy)||1;
  // Perpendicular outward (away from center)
  const px=-dy/len, py=dx/len;
  // Push midpoint outward from origin
  const dot=mx*px+my*py;
  const sign=dot>=0?1:-1;
  const disp=len*amp*sign;
  const sx=mx+px*disp, sy=my+py*disp;
  const left=scallopEdge(ax,ay,sx,sy,depth-1,amp*0.55,outX,outY);
  const right=scallopEdge(sx,sy,bx,by,depth-1,amp*0.55,outX,outY);
  return[...left,...right];
}

function drawLume(c,selType){
  const t=c.traits;
  const mat=c.maturity||0; // 0=newborn, 1=mature
  const growScale=t.birthSize+(1-t.birthSize)*mat;
  // Shape bloom: how much the true hull shape shows vs a circle
  // Before bloomAge fraction of maturity, it's mostly circular
  const bloomFrac=t.bloomAge; // 0.3..0.7
  const shapeBlend=Math.min(Math.max((mat-bloomFrac*0.3)/(1-bloomFrac*0.3),0),1);
  const shapeMix=shapeBlend*shapeBlend; // ease-in: stays orb-like longer

  ctx.save();
  ctx.translate(c.x,c.y);
  ctx.rotate(c.lean);
  ctx.scale(growScale,growScale);

  const nodes=buildLumeShape(t,c.staticHull,c.phase);
  const h1=t.hue, h2=t.hue2, ts=t.toneSplit;
  const gc=`hsla(${h1},${t.sat}%,${Math.min(t.lit+20,85)}%,0.6)`;
  const pg=c.pulseVisual*15;
  const ps=1-c.pulseVisual*.12;
  const cw=t.curveWidth;
  const cornerFrac=0.3+cw*0.2;
  const softness=(1.0-t.stiffness);

  // Scale hull for pulse + apply collision squish deformation
  const cosLean=Math.cos(-c.lean), sinLean=Math.sin(-c.lean);
  const sqLX=c.squishX*cosLean-c.squishY*sinLean;
  const sqLY=c.squishX*sinLean+c.squishY*cosLean;
  const sqMag=Math.hypot(sqLX,sqLY);

  // Compute average radius for circle blend target
  let avgHullR=0;
  for(const nd of nodes) avgHullR+=Math.hypot(nd.x,nd.y);
  avgHullR/=(nodes.length||1);

  const loop=nodes.map(nd=>{
    // Blend between circle and true shape
    const ndR=Math.hypot(nd.x,nd.y)||1;
    const ndAngle=Math.atan2(nd.y,nd.x);
    const circR=avgHullR; // uniform circle radius
    const blendR=circR+(ndR-circR)*shapeMix;
    let bx=Math.cos(ndAngle)*blendR;
    let by=Math.sin(ndAngle)*blendR;

    let x=bx*ps, y=by*ps;
    if(sqMag>0.005){
      const r=blendR||1;
      const dot=(bx*sqLX+by*sqLY)/(r*sqMag);
      const compress=dot*sqMag*r*0.8;
      const expand=(1-Math.abs(dot))*sqMag*r*0.3;
      const nx=bx/r, ny=by/r;
      x+=(-nx*compress+ny*expand)*ps;
      y+=(-ny*compress+nx*expand)*ps;
    }
    return{x,y,r:blendR*ps};
  });

  function traceLoop(lp,sLvl,sAmp){
    const N=lp.length;
    const verts=[];
    for(let i=0;i<N;i++){
      const prev=lp[(i-1+N)%N],curr=lp[i],next=lp[(i+1)%N];
      const tpx=prev.x-curr.x,tpy=prev.y-curr.y;
      const tnx=next.x-curr.x,tny=next.y-curr.y;
      const dp=Math.hypot(tpx,tpy)||1;
      const dn=Math.hypot(tnx,tny)||1;
      const cut=Math.min(dp,dn)*cornerFrac;
      verts.push({
        sx:curr.x+tpx/dp*cut, sy:curr.y+tpy/dp*cut,
        cx:curr.x, cy:curr.y,
        ex:curr.x+tnx/dn*cut, ey:curr.y+tny/dn*cut
      });
    }
    for(let i=0;i<N;i++){
      const v=verts[i];
      const pv=verts[(i-1+N)%N];
      if(i===0){
        if(sLvl>0){
          const pts=scallopEdge(verts[N-1].ex,verts[N-1].ey,v.sx,v.sy,sLvl,sAmp);
          ctx.moveTo(verts[N-1].ex,verts[N-1].ey);
          for(const p of pts) ctx.lineTo(p.x,p.y);
        } else {
          ctx.moveTo(v.sx,v.sy);
        }
      } else {
        if(sLvl>0){
          const pts=scallopEdge(pv.ex,pv.ey,v.sx,v.sy,sLvl,sAmp);
          for(const p of pts) ctx.lineTo(p.x,p.y);
        } else {
          ctx.lineTo(v.sx,v.sy);
        }
      }
      ctx.quadraticCurveTo(v.cx,v.cy,v.ex,v.ey);
    }
    if(sLvl>0){
      const pts=scallopEdge(verts[N-1].ex,verts[N-1].ey,verts[0].sx,verts[0].sy,sLvl,sAmp);
      for(const p of pts) ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
  }

  function tracePath(sLvl,sAmp){
    ctx.beginPath();
    traceLoop(loop,sLvl,sAmp);
  }

  // Scalloping scales with shape maturity â€” orbs have none
  const sL=shapeMix>0.5?t.scallopLvl:0;
  const sA=t.scallopAmp*shapeMix;

  // Bounding box for gradient positioning
  let minY=Infinity,maxY=-Infinity;
  for(const nd of loop){if(nd.y<minY)minY=nd.y;if(nd.y>maxY)maxY=nd.y}
  const spanY=maxY-minY||1;
  const splitY=minY+spanY*ts; // where hue1 transitions to hue2

  // Two-tone linear gradient (topâ†’bottom)
  const bg=ctx.createLinearGradient(0,minY-2,0,maxY+2);
  bg.addColorStop(0,`hsla(${h1},${Math.max(t.sat-5,30)}%,${Math.min(t.lit+20,88)}%,${t.membrane*.7})`);
  bg.addColorStop(Math.max(0,ts-0.15),`hsla(${h1},${t.sat}%,${t.lit}%,${t.membrane*.5})`);
  bg.addColorStop(Math.min(1,ts+0.15),`hsla(${h2},${t.sat}%,${t.lit}%,${t.membrane*.5})`);
  bg.addColorStop(1,`hsla(${h2},${Math.max(t.sat-10,25)}%,${Math.max(t.lit-8,25)}%,${t.membrane*.25})`);

  // Outer glow layer
  ctx.shadowColor=gc;ctx.shadowBlur=t.glow*1.8+pg;
  tracePath(sL,sA);
  ctx.fillStyle=`hsla(${h1},${t.sat}%,${Math.min(t.lit+15,82)}%,${.04+c.pulseVisual*.06})`;
  ctx.fill();

  // Main two-tone fill
  ctx.shadowBlur=t.glow*.6+pg*.4;
  tracePath(sL,sA);
  ctx.fillStyle=bg;ctx.fill();

  // Inner organelles â€” typed, pulse-responsive
  // Fade in during adolescence (after half of bloomAge)
  const orgMatThresh=bloomFrac*0.5;
  const orgAlphaScale=mat<orgMatThresh?0:Math.min((mat-orgMatThresh)/(1-orgMatThresh)*2,1);
  ctx.shadowBlur=0;
  if(c.organelles&&c.organelles.length>0&&orgAlphaScale>0.01){
    ctx.save();
    tracePath(sL,sA);
    ctx.clip();

    const orgHueBase=(h1+t.orgHueShift)%360;
    const baseAlpha=t.membrane*0.45*orgAlphaScale;
    const pv=c.pulseVisual*t.orgPulse; // pulse contribution
    const drift=t.orgDrift;
    const time=c.time;

    // Compute average hull radius for positioning
    let avgR=0;for(const nd of loop)avgR+=Math.hypot(nd.x,nd.y);avgR/=(loop.length||1);

    for(const org of c.organelles){
      // Position: polar coords with drift
      const driftX=Math.sin(time*drift*0.4+org.driftOff)*avgR*0.12;
      const driftY=Math.cos(time*drift*0.3+org.driftOff+1)*avgR*0.1;
      const pulseShrink=1-pv*0.3;
      const r=avgR*org.rFrac*pulseShrink;
      const wobAngle=org.angle+Math.sin(time*0.3+org.phaseOff)*0.15;
      const ox=(Math.cos(wobAngle)*r+driftX)*ps;
      const oy=(Math.sin(wobAngle)*r+driftY)*ps;
      const baseSize=(3+t.orgSize*5)*org.sizeVar;
      const sz=baseSize*(1+pv*0.4);
      const orgHue=(orgHueBase+org.type*40)%360;
      const alpha=baseAlpha*(0.6+pv*0.5);
      const rot=org.elongAngle+time*drift*0.15+Math.sin(time*0.4+org.phaseOff)*0.2;

      ctx.save();
      ctx.translate(ox,oy);
      ctx.rotate(rot);
      ctx.lineWidth=0.5+pv*0.3;
      ctx.lineCap="round";ctx.lineJoin="round";

      if(org.type===0){
        // MANDALA: concentric rings + radial petals
        const nPetals=Math.floor(org.sizeVar*4)+4; // 4-8
        const rings=2+Math.floor(org.sizeVar);
        for(let ri=1;ri<=rings;ri++){
          const rr=sz*ri*0.45;
          const a2=alpha*(0.4-ri*0.08);
          ctx.strokeStyle=`hsla(${orgHue},${t.sat+10}%,${t.lit+25}%,${a2})`;
          ctx.beginPath();ctx.arc(0,0,rr,0,Math.PI*2);ctx.stroke();
        }
        // Petal spokes
        const petalR=sz*rings*0.45;
        for(let p=0;p<nPetals;p++){
          const pa=p*Math.PI*2/nPetals;
          const pulseWob=Math.sin(time*1.5+p*0.8+org.phaseOff)*sz*0.08*t.orgPulse;
          const tipR=petalR+sz*0.3+pulseWob;
          const midR=petalR*0.5;
          // Curved petal: quadratic bezier outward
          const cx1=Math.cos(pa+0.2)*midR, cy1=Math.sin(pa+0.2)*midR;
          const tx=Math.cos(pa)*tipR, ty=Math.sin(pa)*tipR;
          const cx2=Math.cos(pa-0.2)*midR, cy2=Math.sin(pa-0.2)*midR;
          ctx.strokeStyle=`hsla(${(orgHue+p*5)%360},${t.sat+5}%,${t.lit+30}%,${alpha*0.5})`;
          ctx.beginPath();ctx.moveTo(0,0);ctx.quadraticCurveTo(cx1,cy1,tx,ty);ctx.stroke();
          ctx.beginPath();ctx.moveTo(0,0);ctx.quadraticCurveTo(cx2,cy2,tx,ty);ctx.stroke();
        }
        // Center dot
        ctx.beginPath();ctx.arc(0,0,sz*0.15,0,Math.PI*2);
        ctx.fillStyle=`hsla(${orgHue},${t.sat}%,${Math.min(t.lit+40,95)}%,${alpha*0.6})`;ctx.fill();

      }else if(org.type===1){
        // CELTIC KNOT: trefoil / figure-8 loops with over-under
        const nLobes=Math.floor(org.sizeVar*2)+3; // 3-5
        const knotR=sz*0.9;
        const lobeR=knotR*0.45;
        // Draw each lobe as a loop
        for(let li=0;li<nLobes;li++){
          const la=li*Math.PI*2/nLobes;
          const lcx=Math.cos(la)*knotR*0.4, lcy=Math.sin(la)*knotR*0.4;
          // Background (under) pass
          ctx.strokeStyle=`hsla(${orgHue},${t.sat}%,${t.lit+15}%,${alpha*0.2})`;
          ctx.lineWidth=1.8+pv*0.5;
          ctx.beginPath();ctx.arc(lcx,lcy,lobeR,0,Math.PI*2);ctx.stroke();
        }
        // Over pass with gap illusion
        for(let li=0;li<nLobes;li++){
          const la=li*Math.PI*2/nLobes;
          const lcx=Math.cos(la)*knotR*0.4, lcy=Math.sin(la)*knotR*0.4;
          // Draw arcs with gaps at crossings
          const crossAngle=la+Math.PI; // approximate crossing point
          const gapSize=0.4;
          ctx.strokeStyle=`hsla(${(orgHue+li*15)%360},${t.sat+10}%,${t.lit+30}%,${alpha*0.55})`;
          ctx.lineWidth=0.7+pv*0.2;
          ctx.beginPath();
          ctx.arc(lcx,lcy,lobeR,crossAngle+gapSize,crossAngle+Math.PI*2-gapSize);
          ctx.stroke();
        }
        // Center knot point
        ctx.lineWidth=0.5;
        ctx.strokeStyle=`hsla(${orgHue},${t.sat}%,${t.lit+35}%,${alpha*0.4})`;
        ctx.beginPath();ctx.arc(0,0,sz*0.12,0,Math.PI*2);ctx.stroke();

      }else if(org.type===2){
        // SACRED GEOMETRY: flower-of-life overlapping circles
        const seedR=sz*0.35;
        const nRings=Math.floor(org.sizeVar)+1; // 1-2 rings
        const breathe=1+Math.sin(time*0.6+org.phaseOff)*0.1*t.orgPulse;
        // Center circle
        ctx.strokeStyle=`hsla(${orgHue},${t.sat}%,${t.lit+25}%,${alpha*0.4})`;
        ctx.lineWidth=0.45;
        ctx.beginPath();ctx.arc(0,0,seedR*breathe,0,Math.PI*2);ctx.stroke();
        // First ring: 6 circles around center
        for(let ci=0;ci<6;ci++){
          const ca=ci*Math.PI/3;
          const ccx=Math.cos(ca)*seedR*breathe;
          const ccy=Math.sin(ca)*seedR*breathe;
          ctx.strokeStyle=`hsla(${(orgHue+ci*10)%360},${t.sat+5}%,${t.lit+28}%,${alpha*0.35})`;
          ctx.beginPath();ctx.arc(ccx,ccy,seedR*breathe,0,Math.PI*2);ctx.stroke();
        }
        if(nRings>1){
          // Second ring: 12 circles at double radius
          for(let ci=0;ci<12;ci++){
            const ca=ci*Math.PI/6+Math.PI/12;
            const dist=seedR*1.73*breathe;
            const ccx=Math.cos(ca)*dist;
            const ccy=Math.sin(ca)*dist;
            ctx.strokeStyle=`hsla(${(orgHue+ci*8)%360},${t.sat}%,${t.lit+22}%,${alpha*0.2})`;
            ctx.beginPath();ctx.arc(ccx,ccy,seedR*breathe,0,Math.PI*2);ctx.stroke();
          }
        }
        // Center seed dot
        ctx.beginPath();ctx.arc(0,0,sz*0.08,0,Math.PI*2);
        ctx.fillStyle=`hsla(${orgHue},${t.sat}%,${Math.min(t.lit+45,95)}%,${alpha*0.5})`;ctx.fill();

      }else{
        // SPIROGRAPH: hypotrochoid curves
        const R2=sz*0.7;
        const rr=R2*(0.3+org.sizeVar*0.25); // inner radius
        const d2=rr*(0.6+org.sizeVar*0.6); // pen offset
        const nSteps=80;
        const tOffset=time*drift*0.5+org.phaseOff;
        // Multiple harmonics for complexity
        for(let harm=0;harm<2;harm++){
          const hR=R2*(1-harm*0.3);
          const hr=rr*(1+harm*0.2);
          const hd=d2*(1-harm*0.15);
          ctx.strokeStyle=`hsla(${(orgHue+harm*30)%360},${t.sat+10}%,${t.lit+25+harm*8}%,${alpha*(0.4-harm*0.12)})`;
          ctx.lineWidth=0.5-harm*0.1;
          ctx.beginPath();
          for(let s=0;s<=nSteps;s++){
            const tt=s/nSteps*Math.PI*2*3+tOffset; // 3 full loops
            const x2=(hR-hr)*Math.cos(tt)+hd*Math.cos((hR-hr)/hr*tt);
            const y2=(hR-hr)*Math.sin(tt)-hd*Math.sin((hR-hr)/hr*tt);
            if(s===0)ctx.moveTo(x2,y2);else ctx.lineTo(x2,y2);
          }
          ctx.stroke();
        }
        // Animated rotation dot
        const dotAngle=time*1.5+org.phaseOff;
        const dotX=(R2-rr)*Math.cos(dotAngle)+d2*Math.cos((R2-rr)/rr*dotAngle);
        const dotY=(R2-rr)*Math.sin(dotAngle)-d2*Math.sin((R2-rr)/rr*dotAngle);
        ctx.beginPath();ctx.arc(dotX,dotY,sz*0.08,0,Math.PI*2);
        ctx.fillStyle=`hsla(${orgHue},${t.sat}%,${Math.min(t.lit+40,95)}%,${alpha*0.5})`;ctx.fill();
      }

      ctx.restore();
    }
    ctx.restore(); // un-clip
  }

  // Edge stroke â€” blended color
  const midHue=(h1+h2)/2;
  ctx.shadowBlur=t.glow*.3;
  tracePath(sL,sA);
  ctx.strokeStyle=`hsla(${midHue},${t.sat}%,${Math.min(t.lit+30,92)}%,${.25+t.membrane*.3})`;
  // Outline thins with maturity â€” thick protective membrane on young orbs
  const outlineScale=1.8-mat*1.2; // 1.8 â†’ 0.6
  ctx.lineWidth=(1+t.membrane*1.2)*outlineScale;ctx.lineJoin='round';
  ctx.stroke();

  // Center glow (uses primary hue)
  const cnr=6+t.curveWidth*4;
  const cyOff=minY*0.3;
  const cg=ctx.createRadialGradient(0,cyOff,0,0,cyOff,cnr);
  cg.addColorStop(0,`hsla(${h1},${Math.max(t.sat-20,20)}%,${Math.min(t.lit+35,95)}%,${t.membrane*.6})`);
  cg.addColorStop(1,`hsla(${h1},${t.sat}%,${t.lit}%,0)`);
  ctx.shadowColor=gc;ctx.shadowBlur=t.glow;
  ctx.beginPath();ctx.arc(0,cyOff,cnr,0,Math.PI*2);ctx.fillStyle=cg;ctx.fill();

  // Birth flash â€” fades from white glow
  if(c.birthFlash>0.01){
    const bf=c.birthFlash;
    const bfr=t.maxReach*1.2*bf+t.maxReach*0.3;
    const bfg=ctx.createRadialGradient(0,0,0,0,0,bfr);
    bfg.addColorStop(0,`hsla(${h1},30%,95%,${bf*0.4})`);
    bfg.addColorStop(0.4,`hsla(${h1},${t.sat}%,${Math.min(t.lit+30,90)}%,${bf*0.2})`);
    bfg.addColorStop(1,`hsla(${h1},${t.sat}%,${t.lit}%,0)`);
    ctx.beginPath();ctx.arc(0,0,bfr,0,Math.PI*2);ctx.fillStyle=bfg;ctx.fill();
  }

  if(selType){
    const col=selType===1?"rgba(80,170,240,0.55)":selType===2?"rgba(240,160,60,0.55)":"rgba(160,200,160,0.35)";
    ctx.strokeStyle=col;ctx.lineWidth=selType===3?1:2;ctx.setLineDash([5,5]);
    ctx.beginPath();ctx.arc(0,0,t.maxReach+12,0,Math.PI*2);ctx.stroke();ctx.setLineDash([]);
    ctx.beginPath();ctx.arc(0,0,t.maxReach+12,0,Math.PI*2);
    ctx.fillStyle=selType===1?"rgba(80,170,240,0.08)":selType===2?"rgba(240,160,60,0.08)":"rgba(160,200,160,0.04)";ctx.fill();
    ctx.font="bold 10px 'JetBrains Mono',monospace";ctx.textAlign="center";
    ctx.fillStyle=selType===1?"#5ae":selType===2?"#ea5":"#8a9";
    ctx.fillText(selType===1?"P1":selType===2?"P2":"ðŸ‘",0,-t.maxReach-18);
  }
  ctx.restore();
}
function drawCreature(c,selType){
  const t=c.traits;
  const mat=c.maturity||0;
  const trailMat=Math.max((mat-0.05)/0.95,0);
  const trailLen=trailMat*trailMat*trailMat;
  if(trailMat>0.01){
    const prevAlpha=ctx.globalAlpha;
    ctx.globalAlpha=prevAlpha*Math.min(trailMat*2,1); // fade in quickly
    for(const trail of c.trails){
      drawLioTrail(trail.points,t.hue,t.hue2,t.sat,t.lit,t.glow,
        t.thickness*(0.3+trailLen*0.7), // min 30% thickness even as nubs
        t.taper);
    }
    ctx.globalAlpha=prevAlpha;
  }
  drawLume(c,selType);
}

// â”€â”€ Voice Synthesis â”€â”€
let audioCtx=null, voxMaster=null, voxEnabled=true;
const MAX_VOX=4; // max simultaneous voices
let activeVox=0;

function initAudio(){
  if(audioCtx)return;
  try{
    audioCtx=new(window.AudioContext||window.webkitAudioContext)();
    voxMaster=audioCtx.createGain();
    voxMaster.gain.value=0.15; // master volume
    // Soft limiter via compressor
    const comp=audioCtx.createDynamicsCompressor();
    comp.threshold.value=-20;comp.knee.value=12;comp.ratio.value=8;
    voxMaster.connect(comp);comp.connect(audioCtx.destination);
  }catch(e){voxEnabled=false}
}

function voxCall(c){
  if(!voxEnabled)return;
  if(!audioCtx)initAudio();
  if(!audioCtx)return;
  if(audioCtx.state==="suspended")audioCtx.resume();
  if(activeVox>=MAX_VOX)return;
  activeVox++;

  const t=c.traits;
  const now=audioCtx.currentTime;
  const dur=t.voxDur;
  const pitch=t.voxPitch;
  const glide=t.voxGlide;
  const timbre=t.voxTimbre;
  const reverb=t.voxReverb;
  const harmonics=t.voxHarmonics;

  // Pan based on creature x position
  const pan=audioCtx.createStereoPanner?audioCtx.createStereoPanner():null;
  if(pan)pan.pan.value=Math.max(-1,Math.min(1,(c.x/W)*2-1));

  // Output chain: osc â†’ filter â†’ gain â†’ pan â†’ reverb delay â†’ master
  const out=audioCtx.createGain();
  out.gain.value=0;

  // Gentle reverb via feedback delay
  const delay=audioCtx.createDelay(2.0);
  delay.delayTime.value=reverb*0.18+0.04; // 0.04-0.36s
  const fb=audioCtx.createGain();
  fb.gain.value=Math.min(0.45,reverb*0.25); // feedback
  const delayFilter=audioCtx.createBiquadFilter();
  delayFilter.type="lowpass";delayFilter.frequency.value=2000;
  out.connect(delay);delay.connect(delayFilter);delayFilter.connect(fb);fb.connect(delay);
  delay.connect(pan||voxMaster);
  out.connect(pan||voxMaster);
  if(pan)pan.connect(voxMaster);

  // Bandpass filter for vowel-like resonance
  const filt=audioCtx.createBiquadFilter();
  filt.type="bandpass";
  filt.frequency.value=800+timbre*2200; // 800..3000 Hz formant
  filt.Q.value=2+timbre*6; // sharper resonance with timbre

  // Main oscillator â€” sine/triangle blend
  const osc1=audioCtx.createOscillator();
  osc1.type=timbre<0.3?"sine":timbre<0.6?"triangle":"sine";
  osc1.frequency.setValueAtTime(pitch,now);
  osc1.frequency.linearRampToValueAtTime(pitch+glide,now+dur*0.8);
  const g1=audioCtx.createGain();
  g1.gain.value=0.7;

  // Detuned second oscillator for richness
  const osc2=audioCtx.createOscillator();
  osc2.type=timbre<0.5?"sine":"triangle";
  osc2.frequency.setValueAtTime(pitch*1.003,now); // slight detune
  osc2.frequency.linearRampToValueAtTime((pitch+glide)*1.003,now+dur*0.8);
  const g2=audioCtx.createGain();
  g2.gain.value=0.3;

  // Harmonic overtone (octave + fifth)
  const osc3=audioCtx.createOscillator();
  osc3.type="sine";
  const hRatio=timbre<0.4?2:timbre<0.7?3:2.5; // octave, 12th, or octave+fifth
  osc3.frequency.setValueAtTime(pitch*hRatio,now);
  osc3.frequency.linearRampToValueAtTime((pitch+glide)*hRatio,now+dur*0.8);
  const g3=audioCtx.createGain();
  g3.gain.value=harmonics*0.25;

  // Sub-harmonic shimmer (one octave below, very quiet)
  const osc4=audioCtx.createOscillator();
  osc4.type="sine";
  osc4.frequency.setValueAtTime(pitch*0.5,now);
  const g4=audioCtx.createGain();
  g4.gain.value=timbre>0.5?0.12:0.06;

  // Connect oscillators â†’ filter â†’ output
  osc1.connect(g1);g1.connect(filt);
  osc2.connect(g2);g2.connect(filt);
  osc3.connect(g3);g3.connect(filt);
  osc4.connect(g4);g4.connect(filt);
  filt.connect(out);

  // Envelope: quick attack, sustain, gentle release
  const atk=0.012+dur*0.05; // 12-32ms attack
  const rel=dur*0.5+reverb*0.15;
  out.gain.setValueAtTime(0,now);
  out.gain.linearRampToValueAtTime(0.6,now+atk);
  out.gain.setValueAtTime(0.6,now+atk);
  out.gain.exponentialRampToValueAtTime(0.25,now+dur*0.6);
  out.gain.exponentialRampToValueAtTime(0.001,now+dur+rel);

  // Filter sweep: opens then closes
  filt.frequency.setValueAtTime(filt.frequency.value*0.5,now);
  filt.frequency.linearRampToValueAtTime(filt.frequency.value,now+dur*0.3);
  filt.frequency.linearRampToValueAtTime(filt.frequency.value*0.3,now+dur+rel);

  // Start and stop
  const endTime=now+dur+rel+reverb*0.5+0.1;
  [osc1,osc2,osc3,osc4].forEach(o=>{o.start(now);o.stop(endTime)});
  osc1.onended=()=>{activeVox=Math.max(0,activeVox-1)};

  // Visual feedback â€” brief glow pulse
  c.pulseVisual=Math.max(c.pulseVisual||0,0.3);
}

// Initialize audio on first user interaction
document.addEventListener("pointerdown",function initOnce(){
  initAudio();document.removeEventListener("pointerdown",initOnce);
},{once:true});

// â”€â”€ Particles â”€â”€
function initP(){particles=Array.from({length:40},()=>({x:Math.random()*W,y:Math.random()*H,vx:(Math.random()-.5)*.1,vy:-Math.random()*.06-.01,sz:Math.random()*1.3+.3,a:Math.random()*.2+.03}))}
function drawP(){for(const p of particles){p.x+=p.vx;p.y+=p.vy;if(p.x<0)p.x=W;if(p.x>W)p.x=0;if(p.y<0)p.y=H;if(p.y>H)p.y=0;ctx.beginPath();ctx.arc(p.x,p.y,p.sz,0,Math.PI*2);ctx.fillStyle=`rgba(160,200,230,${p.a})`;ctx.fill()}}

// â”€â”€ Bubbles â”€â”€
function emitBubble(c){
  const t=c.traits;
  const hue=(t.hue+t.hue2)/2;
  bubbles.push({
    x:c.x+(Math.random()-0.5)*t.maxReach*0.6,
    y:c.y-t.maxReach*0.3,
    vx:(Math.random()-0.5)*0.3,
    vy:-0.4-Math.random()*0.3,
    r:3+Math.random()*3,
    hue,sat:t.sat,lit:t.lit+20,
    age:0,wobPhase:Math.random()*Math.PI*2,
    popping:false,popT:0,
  });
}
function updateBubbles(dt){
  for(let i=bubbles.length-1;i>=0;i--){
    const b=bubbles[i];
    if(b.popping){
      b.popT+=dt*4;
      if(b.popT>=1){bubbles.splice(i,1);continue;}
      continue;
    }
    b.age+=dt;
    b.vy-=dt*0.08; // gentle upward accel
    b.x+=b.vx+Math.sin(b.age*2+b.wobPhase)*0.3;
    b.y+=b.vy;
    // Pop at top â†’ x1 currency
    if(b.y<-b.r){
      currency+=1;updCurrency();
      floatTexts.push({x:b.x,y:8,text:"+â—¯1",age:0,hue:b.hue});
      bubbles.splice(i,1);
    }
  }
}
function drawBubbles(){
  for(const b of bubbles){
    const popScale=b.popping?1+b.popT*2:1;
    const alpha=b.popping?1-b.popT:Math.min(b.age*3,0.8);
    const r=b.r*popScale;
    // Outer glow
    ctx.beginPath();ctx.arc(b.x,b.y,r+2,0,Math.PI*2);
    ctx.fillStyle=`hsla(${b.hue},${b.sat}%,${b.lit+10}%,${alpha*0.15})`;ctx.fill();
    // Bubble body
    ctx.beginPath();ctx.arc(b.x,b.y,r,0,Math.PI*2);
    const bg=ctx.createRadialGradient(b.x-r*0.3,b.y-r*0.3,0,b.x,b.y,r);
    bg.addColorStop(0,`hsla(${b.hue},${b.sat}%,${Math.min(b.lit+30,95)}%,${alpha*0.7})`);
    bg.addColorStop(0.6,`hsla(${b.hue},${b.sat}%,${b.lit}%,${alpha*0.4})`);
    bg.addColorStop(1,`hsla(${b.hue},${b.sat}%,${b.lit-10}%,${alpha*0.15})`);
    ctx.fillStyle=bg;ctx.fill();
    // Specular highlight
    ctx.beginPath();ctx.arc(b.x-r*0.25,b.y-r*0.25,r*0.3,0,Math.PI*2);
    ctx.fillStyle=`hsla(0,0%,100%,${alpha*0.5})`;ctx.fill();
    if(b.popping){
      // Pop sparkles
      for(let s=0;s<4;s++){
        const sa=s*Math.PI/2+b.popT*2;
        const sd=r*(1+b.popT*3);
        ctx.beginPath();ctx.arc(b.x+Math.cos(sa)*sd,b.y+Math.sin(sa)*sd,1,0,Math.PI*2);
        ctx.fillStyle=`hsla(${b.hue},${b.sat}%,90%,${(1-b.popT)*0.6})`;ctx.fill();
      }
    }
  }
}
function hitBubble(mx,my){
  // Check newest first (on top visually)
  for(let i=bubbles.length-1;i>=0;i--){
    const b=bubbles[i];
    if(b.popping) continue;
    const d=Math.hypot(mx-b.x,my-b.y);
    if(d<b.r+12){ // generous tap target
      return i;
    }
  }
  return -1;
}
function popBubble(idx){
  const b=bubbles[idx];
  b.popping=true;b.popT=0;
  currency+=2;updCurrency();
  floatTexts.push({x:b.x,y:b.y,text:"+â—¯2",age:0,hue:b.hue});
}
function updCurrency(){document.getElementById("currency").textContent="â—¯ "+currency;updBreed()}
function updateFloatTexts(dt){
  for(let i=floatTexts.length-1;i>=0;i--){
    const ft=floatTexts[i];ft.age+=dt;ft.y-=dt*30;
    if(ft.age>1.2)floatTexts.splice(i,1);
  }
}
function drawFloatTexts(){
  ctx.font="bold 11px 'JetBrains Mono',monospace";ctx.textAlign="center";
  for(const ft of floatTexts){
    const a=Math.max(0,1-ft.age/1.2);
    ctx.fillStyle=`hsla(${ft.hue},70%,80%,${a})`;
    ctx.fillText(ft.text,ft.x,ft.y);
  }
}

// â”€â”€ Auto-breeding â”€â”€
// ~1 event per 300s per qualifying pair. Pair qualifies if both mature and within proximity.
function tryAutoBreed(dt){
  const adults=creatures.filter(c=>(c.maturity||0)>=0.95);
  if(adults.length<2) return;
  // Check pairs â€” probability per pair per second = 1/300
  const pPerSec=1/300;
  for(let i=0;i<adults.length;i++){
    for(let j=i+1;j<adults.length;j++){
      const a=adults[i],b=adults[j];
      const d=Math.hypot(a.x-b.x,a.y-b.y);
      const nearDist=(a.traits.maxReach+b.traits.maxReach)*2;
      if(d>nearDist) continue;
      // Closer = higher chance (linear scale)
      const closeness=1-d/nearDist;
      if(Math.random()<pPerSec*dt*closeness){
        doAutoBreed(a,b);
        return; // max one per frame
      }
    }
  }
}
function doAutoBreed(a,b){
  generation++;
  const[g1]=crossover(a.genome,b.genome);
  const mx=(a.x+b.x)/2,my=(a.y+b.y)/2;
  const cx=Math.max(60,Math.min(W-60,mx-15+Math.random()*30));
  const cy=Math.max(60,Math.min(H*0.82,my-15+Math.random()*30));
  const child=createCreature(cx,cy,g1);
  child.gen=generation;
  creatures.push(child);
  // Heart burst between parents
  floatTexts.push({x:mx,y:my-15,text:"â™¥",age:0,hue:350});
  const hue=(a.traits.hue+b.traits.hue)/2;
  for(let k=0;k<8;k++){
    const ang=k*Math.PI/4+Math.random()*0.3;
    const spd=1+Math.random()*1.5;
    hearts.push({
      x:mx,y:my,
      vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd-1,
      age:0,hue,sz:6+Math.random()*6
    });
  }
  // Flash effect on parents
  a.birthFlash=0.6;b.birthFlash=0.6;
}
function updateHearts(dt){
  for(let i=hearts.length-1;i>=0;i--){
    const h=hearts[i];h.age+=dt;
    h.x+=h.vx;h.y+=h.vy;h.vy-=dt*0.5;
    if(h.age>2)hearts.splice(i,1);
  }
}
function drawHearts(){
  for(const h of hearts){
    const a=Math.max(0,1-h.age/2);
    const s=h.sz*(0.5+h.age*0.5);
    ctx.save();ctx.translate(h.x,h.y);ctx.scale(s/12,s/12);
    ctx.beginPath();
    // Heart shape
    ctx.moveTo(0,-4);
    ctx.bezierCurveTo(-6,-10,-12,-4,-12,0);
    ctx.bezierCurveTo(-12,6,-6,10,0,14);
    ctx.bezierCurveTo(6,10,12,6,12,0);
    ctx.bezierCurveTo(12,-4,6,-10,0,-4);
    ctx.closePath();
    ctx.fillStyle=`hsla(${h.hue>180?340:350},85%,70%,${a*0.7})`;
    ctx.fill();
    ctx.strokeStyle=`hsla(0,0%,100%,${a*0.4})`;
    ctx.lineWidth=0.8;ctx.stroke();
    ctx.restore();
  }
}

// â”€â”€ Grow Zones â”€â”€
window.startGrowZone=function(){
  if(currency<10){return}
  placingGrow=true;
  canvas.style.cursor="cell";
};
function placeGrowZone(mx,my){
  if(!placingGrow)return false;
  currency-=10;updCurrency();
  placingGrow=false;
  canvas.style.cursor="crosshair";
  growPreview=null;
  growZones.push({
    x:mx,y:my,r:70,
    life:30, // seconds
    maxLife:30,
    hue:120+Math.random()*40, // green-teal
    pulse:0,
  });
  floatTexts.push({x:mx,y:my-20,text:"-â—¯10",age:0,hue:0});
  return true;
}
function updateGrowZones(dt){
  for(let i=growZones.length-1;i>=0;i--){
    const gz=growZones[i];
    gz.life-=dt;
    gz.pulse+=dt*3;
    if(gz.life<=0){growZones.splice(i,1)}
  }
}
function drawGrowZones(){
  for(const gz of growZones){
    const frac=gz.life/gz.maxLife;
    const alpha=Math.min(frac*3,1); // full brightness most of life
    const pulseR=gz.r+Math.sin(gz.pulse)*6;
    // Big radial glow fill
    const gg=ctx.createRadialGradient(gz.x,gz.y,0,gz.x,gz.y,pulseR);
    gg.addColorStop(0,`hsla(${gz.hue},80%,65%,${alpha*0.3})`);
    gg.addColorStop(0.5,`hsla(${gz.hue},70%,50%,${alpha*0.15})`);
    gg.addColorStop(1,`hsla(${gz.hue},60%,40%,0)`);
    ctx.beginPath();ctx.arc(gz.x,gz.y,pulseR,0,Math.PI*2);
    ctx.fillStyle=gg;ctx.fill();
    // Outer ring â€” bold, dashed, pulsing
    ctx.beginPath();ctx.arc(gz.x,gz.y,pulseR,0,Math.PI*2);
    ctx.strokeStyle=`hsla(${gz.hue},80%,65%,${alpha*0.7})`;
    ctx.lineWidth=2.5;ctx.setLineDash([6,4]);ctx.stroke();ctx.setLineDash([]);
    // Inner ring
    ctx.beginPath();ctx.arc(gz.x,gz.y,pulseR*0.45,0,Math.PI*2);
    ctx.strokeStyle=`hsla(${gz.hue},70%,60%,${alpha*0.35})`;
    ctx.lineWidth=1;ctx.stroke();
    // Rising sparkles â€” 6 of them, orbiting and floating up
    for(let s=0;s<6;s++){
      const sa=gz.pulse*0.6+s*Math.PI*2/6;
      const sr=pulseR*(0.15+Math.abs(Math.sin(gz.pulse*0.7+s*1.1))*0.65);
      const sx=gz.x+Math.cos(sa)*sr;
      const sy=gz.y+Math.sin(sa)*sr*0.5-Math.abs(Math.sin(gz.pulse*1.3+s*2))*pulseR*0.3;
      const sparkSz=1.5+Math.sin(gz.pulse*2+s)*0.8;
      ctx.beginPath();ctx.arc(sx,sy,sparkSz,0,Math.PI*2);
      ctx.fillStyle=`hsla(${gz.hue+s*10},85%,80%,${alpha*0.8})`;ctx.fill();
    }
    // Timer arc â€” thick, bright
    ctx.beginPath();ctx.arc(gz.x,gz.y,pulseR+6,Math.PI*1.5,Math.PI*1.5+Math.PI*2*frac);
    ctx.strokeStyle=`hsla(${gz.hue},85%,75%,${alpha*0.9})`;
    ctx.lineWidth=3;ctx.lineCap="round";ctx.stroke();ctx.lineCap="butt";
    // Center label â€” multiplier and countdown
    ctx.font="bold 11px 'JetBrains Mono',monospace";ctx.textAlign="center";
    ctx.fillStyle=`hsla(${gz.hue},80%,80%,${alpha*0.9})`;
    ctx.fillText("Ã—4",gz.x,gz.y-2);
    ctx.font="9px 'JetBrains Mono',monospace";
    ctx.fillStyle=`hsla(${gz.hue},70%,70%,${alpha*0.6})`;
    ctx.fillText(Math.ceil(gz.life)+"s",gz.x,gz.y+10);
  }
}
function growZoneMultiplier(cx,cy){
  let mult=1;
  for(const gz of growZones){
    const d=Math.hypot(cx-gz.x,cy-gz.y);
    if(d<gz.r){
      const frac=gz.life/gz.maxLife;
      const strength=1-d/gz.r; // stronger at center
      mult+=3*strength*Math.min(frac*2,1); // up to 4x at center
    }
  }
  return mult;
}

// â”€â”€ Substrate: rocks, plants, sand bed â”€â”€
let substrate={rocks:[],plants:[],pebbles:[]};
function seededRand(s){return function(){s=(s*9301+49297)%233280;return s/233280}}

function initSubstrate(){
  const rng=seededRand(42);
  const baseY=H*0.88; // substrate starts at 88% height
  const rocks=[], plants=[], pebbles=[];

  // Sand bed height map â€” gentle rolling dunes
  const sandPts=[];
  const nSand=Math.ceil(W/12)+1;
  for(let i=0;i<nSand;i++){
    const x=i*12;
    const y=baseY+Math.sin(i*0.3)*6+Math.sin(i*0.13+2)*4+rng()*5;
    sandPts.push({x,y});
  }
  substrate.sandPts=sandPts;
  substrate.baseY=baseY;

  // Rocks: irregular polygons
  const nRocks=Math.floor(3+rng()*5);
  for(let i=0;i<nRocks;i++){
    const cx=W*0.08+rng()*W*0.84;
    const cy=baseY+rng()*12+4;
    const baseR=8+rng()*22;
    const nSides=Math.floor(4+rng()*4); // 4-7 sides
    const hue=200+rng()*40; // blue-grey-teal
    const lit=12+rng()*14;
    const verts=[];
    for(let j=0;j<nSides;j++){
      const a=(j/nSides)*Math.PI*2-Math.PI/2;
      const r=baseR*(0.6+rng()*0.5);
      verts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r*0.6}); // squash vertically
    }
    rocks.push({verts,hue,lit,cx,cy,r:baseR});
  }
  // Sort rocks by Y so further ones draw first
  rocks.sort((a,b)=>a.cy-b.cy);
  substrate.rocks=rocks;

  // Pebbles: small circles scattered across substrate
  const nPeb=Math.floor(15+rng()*20);
  for(let i=0;i<nPeb;i++){
    const x=rng()*W;
    const y=baseY+rng()*18-4;
    const r=1+rng()*3;
    const lit=10+rng()*12;
    pebbles.push({x,y,r,lit});
  }
  substrate.pebbles=pebbles;

  // Plants: stalks with leaf blades
  const nPlants=Math.floor(4+rng()*6);
  for(let i=0;i<nPlants;i++){
    const rootX=W*0.05+rng()*W*0.9;
    const rootY=baseY+rng()*6;
    const nStalks=Math.floor(2+rng()*4); // 2-5 stalks per cluster
    const plantHue=100+rng()*60; // greens to teals
    const stalks=[];
    for(let s=0;s<nStalks;s++){
      const height=25+rng()*50;
      const sway=0.15+rng()*0.3; // sway amplitude
      const swaySpeed=0.4+rng()*0.6;
      const swayPhase=rng()*Math.PI*2;
      const curve=(rng()-0.5)*0.4; // lean bias
      const nSegs=Math.floor(3+rng()*3); // 3-5 segments
      const width=1.5+rng()*2.5;
      // Leaf blades along stalk
      const leaves=[];
      const nLeaves=Math.floor(1+rng()*3);
      for(let l=0;l<nLeaves;l++){
        const frac=0.3+rng()*0.5; // position along stalk
        const side=rng()>0.5?1:-1;
        const len=6+rng()*12;
        const leafAngle=side*(0.3+rng()*0.6);
        leaves.push({frac,side,len,leafAngle,hueOff:rng()*20-10});
      }
      stalks.push({height,sway,swaySpeed,swayPhase,curve,nSegs,width,leaves,
                    offX:(rng()-0.5)*12}); // cluster spread
    }
    plants.push({rootX,rootY,stalks,hue:plantHue,sat:30+rng()*25,lit:20+rng()*15});
  }
  substrate.plants=plants;
}

function drawSubstrate(time){
  const t=time*0.001;

  // Sand bed
  ctx.beginPath();
  const sp=substrate.sandPts;
  if(sp&&sp.length>0){
    ctx.moveTo(sp[0].x,sp[0].y);
    for(let i=1;i<sp.length;i++) ctx.lineTo(sp[i].x,sp[i].y);
    ctx.lineTo(W,H+5);ctx.lineTo(0,H+5);ctx.closePath();
    const sg=ctx.createLinearGradient(0,substrate.baseY-5,0,H);
    sg.addColorStop(0,"#0c1a24");
    sg.addColorStop(0.3,"#0a1520");
    sg.addColorStop(1,"#060e18");
    ctx.fillStyle=sg;ctx.fill();
    // Sand edge highlight
    ctx.beginPath();
    ctx.moveTo(sp[0].x,sp[0].y);
    for(let i=1;i<sp.length;i++) ctx.lineTo(sp[i].x,sp[i].y);
    ctx.strokeStyle="rgba(80,110,130,0.15)";ctx.lineWidth=1.5;ctx.stroke();
  }

  // Pebbles
  for(const p of substrate.pebbles){
    ctx.beginPath();ctx.ellipse(p.x,p.y,p.r,p.r*0.65,0,0,Math.PI*2);
    ctx.fillStyle=`hsl(210,15%,${p.lit}%)`;ctx.fill();
    ctx.strokeStyle=`hsl(210,10%,${p.lit+5}%)`;ctx.lineWidth=0.4;ctx.stroke();
  }

  // Rocks
  for(const rock of substrate.rocks){
    const v=rock.verts;
    // Shadow
    ctx.beginPath();
    ctx.moveTo(v[0].x+3,v[0].y+2);
    for(let i=1;i<v.length;i++) ctx.lineTo(v[i].x+3,v[i].y+2);
    ctx.closePath();
    ctx.fillStyle="rgba(0,0,0,0.2)";ctx.fill();
    // Main body
    ctx.beginPath();
    ctx.moveTo(v[0].x,v[0].y);
    for(let i=1;i<v.length;i++) ctx.lineTo(v[i].x,v[i].y);
    ctx.closePath();
    const rg=ctx.createLinearGradient(rock.cx,rock.cy-rock.r*0.4,rock.cx,rock.cy+rock.r*0.3);
    rg.addColorStop(0,`hsl(${rock.hue},18%,${rock.lit+8}%)`);
    rg.addColorStop(1,`hsl(${rock.hue},12%,${rock.lit}%)`);
    ctx.fillStyle=rg;ctx.fill();
    // Edge highlight
    ctx.strokeStyle=`hsla(${rock.hue},15%,${rock.lit+12}%,0.3)`;
    ctx.lineWidth=0.8;ctx.lineJoin="round";ctx.stroke();
    // Top shine
    ctx.beginPath();
    ctx.moveTo(v[0].x,v[0].y);
    const mid=Math.floor(v.length/2);
    for(let i=1;i<=mid;i++) ctx.lineTo(v[i].x,v[i].y);
    ctx.strokeStyle=`hsla(${rock.hue},20%,${rock.lit+18}%,0.15)`;
    ctx.lineWidth=1.2;ctx.stroke();
  }

  // Plants: swaying stalks with leaf blades
  for(const plant of substrate.plants){
    for(const stalk of plant.stalks){
      const rootX=plant.rootX+stalk.offX;
      const rootY=plant.rootY;
      const swayNow=Math.sin(t*stalk.swaySpeed+stalk.swayPhase)*stalk.sway;
      // Build stalk points from root upward
      const pts=[{x:rootX,y:rootY}];
      for(let s=1;s<=stalk.nSegs;s++){
        const frac=s/stalk.nSegs;
        const y=rootY-stalk.height*frac;
        // Cumulative sway increases toward tip
        const xOff=swayNow*frac*frac*stalk.height*0.4+stalk.curve*frac*stalk.height*0.3;
        pts.push({x:rootX+xOff, y});
      }
      // Draw stalk
      ctx.beginPath();
      ctx.moveTo(pts[0].x,pts[0].y);
      for(let s=1;s<pts.length;s++){
        // Slight curve between segments
        const prev=pts[s-1],curr=pts[s];
        const cpx=(prev.x+curr.x)/2+swayNow*3*(s/stalk.nSegs);
        const cpy=(prev.y+curr.y)/2;
        ctx.quadraticCurveTo(cpx,cpy,curr.x,curr.y);
      }
      const stalkAlpha=0.4+stalk.width*0.08;
      ctx.strokeStyle=`hsla(${plant.hue},${plant.sat}%,${plant.lit}%,${stalkAlpha})`;
      ctx.lineWidth=stalk.width;ctx.lineCap="round";ctx.stroke();
      // Thinner bright core
      ctx.strokeStyle=`hsla(${plant.hue},${plant.sat+10}%,${plant.lit+12}%,${stalkAlpha*0.4})`;
      ctx.lineWidth=stalk.width*0.35;ctx.stroke();

      // Leaf blades
      for(const leaf of stalk.leaves){
        // Interpolate position along stalk
        const segF=leaf.frac*stalk.nSegs;
        const si=Math.min(Math.floor(segF),pts.length-2);
        const sf=segF-si;
        const bx=pts[si].x+(pts[si+1].x-pts[si].x)*sf;
        const by=pts[si].y+(pts[si+1].y-pts[si].y)*sf;
        // Leaf direction: angled from stalk
        const stalkAngle=Math.atan2(pts[si+1].y-pts[si].y,pts[si+1].x-pts[si].x);
        const la=stalkAngle+leaf.leafAngle+swayNow*0.3*leaf.side;
        const tipX=bx+Math.cos(la)*leaf.len;
        const tipY=by+Math.sin(la)*leaf.len;
        // Draw as elongated triangle
        const perp=la+Math.PI/2;
        const hw=1.5+stalk.width*0.3;
        ctx.beginPath();
        ctx.moveTo(bx+Math.cos(perp)*hw,by+Math.sin(perp)*hw);
        ctx.lineTo(tipX,tipY);
        ctx.lineTo(bx-Math.cos(perp)*hw,by-Math.sin(perp)*hw);
        ctx.closePath();
        const lh=plant.hue+leaf.hueOff;
        ctx.fillStyle=`hsla(${lh},${plant.sat+5}%,${plant.lit+6}%,${stalkAlpha*0.7})`;
        ctx.fill();
        // Leaf midrib
        ctx.beginPath();ctx.moveTo(bx,by);ctx.lineTo(tipX,tipY);
        ctx.strokeStyle=`hsla(${lh},${plant.sat}%,${plant.lit+15}%,${stalkAlpha*0.3})`;
        ctx.lineWidth=0.5;ctx.stroke();
      }
    }
  }
}

function resize(){
  const wrap=document.getElementById("tank-wrap");
  W=wrap.clientWidth;H=wrap.clientHeight;
  const dpr=window.devicePixelRatio||1;
  canvas.width=W*dpr;canvas.height=H*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  // Re-clamp all creatures into new bounds
  for(const c of creatures){
    const pad=15+c.traits.maxReach*0.5;
    const bpad=H*0.13+c.traits.maxReach*0.5;
    c.x=Math.max(pad,Math.min(W-pad,c.x));
    c.y=Math.max(pad,Math.min(H-bpad,c.y));
  }
}

function hitCreature(mx,my){
  let cl=null,cd=Infinity;
  let nearCl=null,nearD=Infinity; // fallback: nearest by distance
  for(const c of creatures){
    const d=Math.hypot(c.x-mx,c.y-my);
    const growS=c.traits.birthSize+(1-c.traits.birthSize)*(c.maturity||0);
    const r=c.traits.maxReach*1.3*growS+15;
    if(d>r)continue;
    // Transform mouse into creature local space (undo lean + translate)
    const dx=mx-c.x, dy=my-c.y;
    const cosL=Math.cos(-c.lean), sinL=Math.sin(-c.lean);
    const lx=dx*cosL-dy*sinL, ly=dx*sinL+dy*cosL;
    // Point-in-polygon on wobbled hull
    const hull=buildLumeShape(c.traits,c.staticHull,c.phase);
    const n=hull.length;
    let inside=false;
    for(let i=0,j=n-1;i<n;j=i++){
      const xi=hull[i].x,yi=hull[i].y,xj=hull[j].x,yj=hull[j].y;
      if(((yi>ly)!==(yj>ly))&&(lx<(xj-xi)*(ly-yi)/(yj-yi)+xi))inside=!inside;
    }
    if(inside&&d<cd){cl=c;cd=d}
    // Track nearest creature within generous radius as fallback
    if(d<nearD){nearD=d;nearCl=c}
  }
  // Prefer exact hull hit; fall back to nearest within radius
  return cl||nearCl;
}

function handleSelect(mx,my){
  const cl=hitCreature(mx,my);
  if(!cl){parent1Id=parent2Id=viewId=null}
  else handleSelectById(cl.id);
  updUI();
}
function handleSelectById(cid){
  const cl=creatures.find(c=>c.id===cid);
  if(!cl)return;
  voxCall(cl); // vocalize on tap
  const isMature=(cl.maturity||0)>=0.95;
  viewId=cl.id; // always allow viewing
  if(!isMature){
    // Immature: view only, don't assign as parent
    updUI();return;
  }
  if(!parent1Id||cl.id===parent1Id){
    if(cl.id===parent1Id){parent1Id=parent2Id;parent2Id=null;viewId=parent1Id}
    else{parent1Id=cl.id;viewId=cl.id}
  }else if(cl.id===parent2Id){parent2Id=null;viewId=parent1Id}
  else{parent2Id=cl.id;viewId=cl.id}
  updUI();
}
function getSelType(c){if(c.id===parent1Id)return 1;if(c.id===parent2Id)return 2;if(c.id===viewId)return 3;return 0}

function startDrag(mx,my){if(placeGrowZone(mx,my))return;const bi=hitBubble(mx,my);if(bi>=0){popBubble(bi);return}const cl=hitCreature(mx,my);if(cl){dragId=cl.id;dragOff.x=cl.x-mx;dragOff.y=cl.y-my;isDragging=false;dragStartTime=performance.now();dragStartX=mx;dragStartY=my;canvas.style.cursor="grabbing"}else{dragId=null;isDragging=false;dragStartTime=performance.now();dragStartX=mx;dragStartY=my}}
function moveDrag(mx,my){if(!dragId)return;const c=creatures.find(c=>c.id===dragId);if(!c)return;const dx=mx-dragStartX,dy=my-dragStartY;if(!isDragging&&Math.hypot(dx,dy)<5)return;isDragging=true;const pad=15+c.traits.maxReach*0.5;const bpad=H*0.13+c.traits.maxReach*0.5;c.x=Math.max(pad,Math.min(W-pad,mx+dragOff.x));c.y=Math.max(pad,Math.min(H-bpad,my+dragOff.y));c.vx=0;c.vy=0}
function endDrag(mx,my){if(dragId){const wasDrag=isDragging;const clickedId=dragId;const c=creatures.find(c=>c.id===dragId);if(c){c.vx=0;c.vy=0}canvas.style.cursor="crosshair";dragId=null;if(!wasDrag)handleSelectById(clickedId)}else{if(!isDragging){const moved=Math.hypot(mx-dragStartX,my-dragStartY);if(moved<5)handleSelect(mx,my)}canvas.style.cursor="crosshair"}}

// â”€â”€ Helix DNA visualization â”€â”€
const HELIX_TURNS=5.2; // full turns across 52 BP
const HELIX_RAD=32; // helix radius in px
const HELIX_RUNG_SP=8; // vertical spacing per BP
const HELIX_ROT_SPEED=0.3; // rad/s
let helixCtx=null;

function initHelixCanvas(){
  const hc=document.getElementById("helix-canvas");
  if(!hc)return;
  const dpr=window.devicePixelRatio||1;
  const w=hc.clientWidth||280;
  const h=BPC*HELIX_RUNG_SP+30;
  hc.width=w*dpr;hc.height=h*dpr;
  hc.style.height=h+"px";
  helixCtx=hc.getContext("2d");
  helixCtx.scale(dpr,dpr);
  // Click handler
  hc.onclick=function(e){
    if(!helixGenome||!helixCreatureId)return;
    const rect=hc.getBoundingClientRect();
    const my=(e.clientY-rect.top);
    const idx=Math.round((my-15)/HELIX_RUNG_SP);
    if(idx>=0&&idx<BPC) toggleBP(helixCreatureId,idx);
  };
  hc.onmousemove=function(e){
    const rect=hc.getBoundingClientRect();
    const my=(e.clientY-rect.top);
    helixHoverBP=Math.round((my-15)/HELIX_RUNG_SP);
    if(helixHoverBP<0||helixHoverBP>=BPC)helixHoverBP=-1;
  };
  hc.onmouseleave=function(){helixHoverBP=-1};
}

function drawHelixFrame(dt){
  if(!helixCtx)return;
  if(!helixGenome){
    const hc=document.getElementById("helix-canvas");
    if(hc){const dpr=window.devicePixelRatio||1;helixCtx.clearRect(0,0,hc.width/dpr,(hc.height||1)/dpr)}
    return;
  }
  helixAngle+=HELIX_ROT_SPEED*dt;
  const hc=document.getElementById("helix-canvas");
  if(!hc)return;
  const w=hc.clientWidth||280;
  const h=BPC*HELIX_RUNG_SP+30;
  const cx=Math.min(w*0.35,80);

  // Check if canvas needs resize
  const dpr=window.devicePixelRatio||1;
  if(Math.abs(hc.width-w*dpr)>2){
    hc.width=w*dpr;hc.height=h*dpr;
    hc.style.height=h+"px";
    helixCtx.scale(dpr,dpr);
  }

  const hx=helixCtx;
  hx.clearRect(0,0,w,h);

  const genome=helixGenome;
  const litSet=helixLitSet;

  // Build rung data with z-depth for sorting
  const rungs=[];
  for(let i=0;i<BPC;i++){
    const ang=helixAngle+i*(Math.PI*2*HELIX_TURNS/BPC);
    const y=15+i*HELIX_RUNG_SP;
    const cosA=Math.cos(ang),sinA=Math.sin(ang);
    // Strand 1 (left helix)
    const x1=cx+cosA*HELIX_RAD;
    // Strand 2 (right helix, Ï€ offset)
    const x2=cx-cosA*HELIX_RAD;
    const z=sinA; // -1 to 1, for depth
    rungs.push({i,y,x1,x2,z,ang,cosA,sinA});
  }

  // Sort back-to-front for proper overlap
  const sorted=[...rungs].sort((a,b)=>a.z-b.z);

  // Draw backbone strands with depth-varying alpha
  for(let strand=0;strand<2;strand++){
    for(let i=0;i<BPC-1;i++){
      const r0=rungs[i],r1=rungs[i+1];
      const sx0=strand===0?r0.x1:r0.x2;
      const sx1=strand===0?r1.x1:r1.x2;
      // Strand 0 depth = sinA, Strand 1 depth = -sinA (Ï€ offset)
      const z0=strand===0?r0.sinA:-r0.sinA;
      const z1=strand===0?r1.sinA:-r1.sinA;
      const avgZ=(z0+z1)/2;
      const bAlpha=0.06+Math.max(0,avgZ+1)*0.14;
      hx.beginPath();hx.moveTo(sx0,r0.y);hx.lineTo(sx1,r1.y);
      hx.strokeStyle=`rgba(80,150,200,${bAlpha})`;
      hx.lineWidth=1.2+Math.max(0,avgZ)*1;hx.stroke();
    }
  }

  // Draw rungs
  for(const r of sorted){
    const {i,y,x1,x2,z,cosA,sinA}=r;
    const base=genome[i];
    const comp=COMP[base];
    const depth=0.35+Math.max(0,z+1)*0.325; // 0.35..1.0

    // Determine highlight state
    let highlight=false,dimmed=false;
    if(litSet){
      if(litSet.has(i))highlight=true;else dimmed=true;
    }
    const isHover=i===helixHoverBP;

    const alpha=dimmed?0.12:depth;
    const rungAlpha=dimmed?0.06:depth*0.5;

    // Rung line (hydrogen bond)
    hx.beginPath();hx.moveTo(x1,y);hx.lineTo(x2,y);
    const rungW=dimmed?0.3:0.6+depth*0.8;
    hx.strokeStyle=highlight?`rgba(140,200,255,${rungAlpha+0.3})`:`rgba(80,130,170,${rungAlpha})`;
    hx.lineWidth=rungW;hx.stroke();

    // Base dots
    const dotR=dimmed?1.5:2.2+depth*1.8+(isHover?1.5:0)+(highlight?1:0);
    // Left dot (base)
    hx.beginPath();hx.arc(x1,y,dotR,0,Math.PI*2);
    const bc=BCOL[base];
    hx.fillStyle=dimmed?`rgba(60,80,100,0.15)`:
      highlight?bc:
      `rgba(${hexR(bc)},${hexG(bc)},${hexB(bc)},${alpha})`;
    hx.fill();
    // Right dot (complement)
    hx.beginPath();hx.arc(x2,y,dotR,0,Math.PI*2);
    const cc=BCOL[comp];
    hx.fillStyle=dimmed?`rgba(60,80,100,0.15)`:
      highlight?cc:
      `rgba(${hexR(cc)},${hexG(cc)},${hexB(cc)},${alpha})`;
    hx.fill();

    // Backbone node dots (vertebrae)
    if(!dimmed){
      const bbAlpha=depth*0.3;
      hx.beginPath();hx.arc(x1,y,1+depth,0,Math.PI*2);
      hx.fillStyle=`rgba(100,160,200,${bbAlpha})`;hx.fill();
      hx.beginPath();hx.arc(x2,y,1+depth,0,Math.PI*2);
      hx.fillStyle=`rgba(100,160,200,${bbAlpha})`;hx.fill();
    }
  }

  // â”€â”€ Tile strip: base pair readout aligned with helix â”€â”€
  const tileX=cx+HELIX_RAD+18;
  const tileW=w-tileX-4;
  const tH=HELIX_RUNG_SP-1.5;
  const idxW=16;
  const baseW=Math.min(20,(tileW-idxW-2)/2);
  hx.font="bold 8px 'JetBrains Mono',monospace";
  for(let i=0;i<BPC;i++){
    const y=15+i*HELIX_RUNG_SP;
    const ty=y-tH/2;
    const base=genome[i];
    const comp=COMP[base];
    let hl=false,dim=false;
    if(litSet){if(litSet.has(i))hl=true;else dim=true}
    const isH=i===helixHoverBP;
    const tA=dim?0.1:isH?1:hl?0.9:0.5;
    // Faint connection line
    if(!dim){
      hx.beginPath();hx.moveTo(cx+HELIX_RAD+3,y);hx.lineTo(tileX-2,y);
      hx.strokeStyle=`rgba(60,100,140,${tA*0.15})`;hx.lineWidth=0.5;hx.stroke();
    }
    // Index
    hx.fillStyle=`rgba(80,120,160,${tA*0.6})`;
    hx.textAlign="right";
    hx.fillText(i+"",tileX+idxW-2,y+3);
    // Base tile
    const bx=tileX+idxW+1;
    const bc2=BCOL[base];
    hx.fillStyle=dim?`rgba(20,30,45,0.3)`:
      hl?bc2+"30":isH?bc2+"40":`rgba(20,35,55,${tA*0.5})`;
    hx.fillRect(bx,ty,baseW,tH);
    if(hl||isH){hx.strokeStyle=bc2+"88";hx.lineWidth=0.5;hx.strokeRect(bx,ty,baseW,tH)}
    hx.fillStyle=dim?`rgba(60,80,100,0.15)`:bc2;
    hx.globalAlpha=dim?0.2:tA;
    hx.textAlign="center";
    hx.fillText(base,bx+baseW/2,y+3);
    hx.globalAlpha=1;
    // Complement tile
    const cx2=bx+baseW+1;
    const cc2=BCOL[comp];
    hx.fillStyle=dim?`rgba(20,30,45,0.2)`:
      hl?cc2+"20":isH?cc2+"25":`rgba(20,35,55,${tA*0.25})`;
    hx.fillRect(cx2,ty,baseW,tH);
    hx.fillStyle=dim?`rgba(60,80,100,0.1)`:cc2;
    hx.globalAlpha=dim?0.15:tA*0.5;
    hx.fillText(comp,cx2+baseW/2,y+3);
    hx.globalAlpha=1;
  }
}

// Hex color component extractors
function hexR(c){return parseInt(c.slice(1,3),16)}
function hexG(c){return parseInt(c.slice(3,5),16)}
function hexB(c){return parseInt(c.slice(5,7),16)}

// â”€â”€ UI â”€â”€
function updUI(){updCnt();updBreed();updStatus();buildPanel();document.getElementById("hint").style.display=(parent1Id||parent2Id||viewId)?"none":"";document.getElementById("codex-count").textContent=codex.size}
function updCnt(){document.getElementById("cnt").textContent=creatures.length+" in tank"}
function updBreed(){
  const breedReady=!!(parent1Id&&parent2Id);
  const canAfford=currency>=10;
  const bb=document.getElementById("breed-btn");
  bb.classList.toggle("show",breedReady);
  bb.textContent=breedReady?(canAfford?"âš­ BREED (â—¯10)":"âš­ NEED â—¯10"):"âš­ BREED";
  bb.style.opacity=breedReady&&!canAfford?"0.4":"1";
  const sb=document.getElementById("sell-btn");
  const showSell=!!(viewId&&!parent2Id);
  sb.classList.toggle("show",showSell);
  if(showSell&&viewId){
    const sv=creatures.find(c=>c.id===viewId);
    sb.textContent=sv&&(sv.maturity||0)>=0.95?"âœ• SELL (+â—¯10)":"âœ• SELL";
  }
  const spb=document.getElementById("spawn-btn");
  spb.style.opacity=currency>=15?"1":"0.4";
  const gb=document.getElementById("grow-btn");
  gb.style.opacity=currency>=10?"1":"0.4";
}
function updStatus(){
  const bar=document.getElementById("status-bar");
  const p1=creatures.find(c=>c.id===parent1Id),p2=creatures.find(c=>c.id===parent2Id);
  if(!p1&&!p2){bar.classList.remove("show");return}
  bar.classList.add("show");let h="";
  if(p1)h+=`<span class="status-chip p1"><span class="dot p1"></span>P1 G${p1.gen}</span>`;
  if(p1&&!p2)h+=`<span style="color:#3a5a6a;margin:0 4px">tap another</span>`;
  if(p2)h+=`<span class="status-chip p2"><span class="dot p2"></span>P2 G${p2.gen}</span>`;
  if(p1&&p2)h+=`<span style="color:#8a6ab0;margin:0 4px">ready</span>`;
  document.getElementById("status-text").innerHTML=h;
}
function buildPanel(){
  const show=viewId||parent1Id;const sel=creatures.find(c=>c.id===show);
  if(!sel){
    document.getElementById("sel-info").innerHTML=`<span style="color:#3a5a6a">No selection</span>`;
    helixGenome=null;helixCreatureId=null;helixLitSet=null;
    document.getElementById("traits").innerHTML="";
    document.getElementById("phenotype").textContent="";
    document.getElementById("pheno-tags").innerHTML="";
    const m=document.getElementById("bp-info");if(m)m.textContent="";
    return;
  }
  const selMature=(sel.maturity||0)>=0.95;
  document.getElementById("sel-info").innerHTML=
    (sel.id===parent1Id?`<span style="color:#5ae;font-weight:600">â— P1</span> `:
     sel.id===parent2Id?`<span style="color:#ea5;font-weight:600">â— P2</span> `:"")+
    `<span style="color:#4a6a8a">Gen ${sel.gen||0}</span>`+
    ` <span style="color:#8a7a4a">${(sel.maturity||0)<0.1?"ðŸ¥š Egg":(sel.maturity||0)<0.3?"ðŸ«§ Larva":(sel.maturity||0)<0.6?"â— Juvenile":(sel.maturity||0)<0.95?"â—‘ Adolescent":"â— Mature"}</span>`+
    ` <span style="color:#5a6a5a;font-size:8px">${fmtAge(sel.age||0)}</span>`+
    (!selMature&&sel.id!==parent1Id&&sel.id!==parent2Id?` <span style="color:#6a4a4a;font-size:7px">too young to breed</span>`:"");
  // Set up helix data
  helixGenome=sel.genome;
  helixCreatureId=sel.id;
  initHelixCanvas();
  // Phenotype summary
  const ph=phenotype(sel.traits);
  sel.phenotype=ph;
  const sKey=speciesKey(ph.tags);
  const codexEntry=codex.get(sKey);
  const discovered=!!codexEntry;
  const speciesName=codexEntry&&codexEntry.name?codexEntry.name:null;
  if(discovered){
    document.getElementById("phenotype").innerHTML=
      (speciesName?`<span style="color:#ec8;font-weight:600;font-size:10px;font-style:italic">${speciesName}</span> â€” `:"")+
      ph.prose;
    const ptDiv=document.getElementById("pheno-tags");ptDiv.innerHTML="";
    for(const tag of ph.tags){
      const pill=document.createElement("span");pill.className="ptag";
      pill.textContent=tag;
      const tc=TAG_COLORS[tag]||"#7ab";
      pill.style.color=tc;
      pill.style.borderColor=tc+"44";
      pill.style.background=tc+"18";
      ptDiv.appendChild(pill);
    }
  }else{
    document.getElementById("phenotype").innerHTML=`<span style="color:#4a5a6a;font-style:italic">Species unknown â€” raise to maturity to identify</span>`;
    document.getElementById("pheno-tags").innerHTML="";
  }
  const td=document.getElementById("traits");td.innerHTML="";
  const vals=tvs(sel.traits);
  for(const[cat,label]of[["lume","â—† LUME"],["move","âŸ¡ MOVE"],["lio","â‰ˆ LIO"],["org","âŠ™ ORG"],["grow","â†‘ GROW"],["vox","â™ª VOX"]]){
    const col=document.createElement("div");col.className="tcol "+cat;
    col.innerHTML=`<h4>${label}</h4>`;
    for(const[name,inf]of Object.entries(TRAITS)){
      if(inf.cat!==cat)continue;
      const row=document.createElement("div");row.className="trow"+(activeTrait===name?" active":"");
      row.innerHTML=`<span class="tn">${name}</span><span class="tv">${inf.fmt(vals[name])}</span>`;
      row.addEventListener("click",e=>{e.stopPropagation();toggleTrait(name)});
      row.addEventListener("mouseenter",()=>{if(window.innerWidth>=700)hlBP(name)});
      row.addEventListener("mouseleave",()=>{if(window.innerWidth>=700)clBP()});
      col.appendChild(row);
    }
    td.appendChild(col);
  }
  let mapDiv=document.getElementById("bp-map");
  if(!mapDiv){mapDiv=document.createElement("div");mapDiv.id="bp-map"}
  mapDiv.innerHTML=`<div class="ml">BASE PAIR MAP</div><span id="bp-info">${activeTrait?'':'Tap a trait'}</span>`;
  td.appendChild(mapDiv);
  if(activeTrait)hlBP(activeTrait);
}
function toggleTrait(name){
  activeTrait=activeTrait===name?null:name;
  if(activeTrait)hlBP(activeTrait);else clBP();
  document.querySelectorAll(".trow").forEach(r=>r.classList.remove("active"));
  if(activeTrait)document.querySelectorAll(".trow").forEach(r=>{if(r.querySelector(".tn").textContent===activeTrait)r.classList.add("active")});
}
function hlBP(name){
  helixLitSet=new Set(TRAITS[name].bp);
  const m=document.getElementById("bp-info");
  if(m)m.innerHTML=`<span style="color:#8ab">${name}</span> â†’ BP <span style="font-weight:600">[${TRAITS[name].bp.join(", ")}]</span>`;
}
function clBP(){
  helixLitSet=null;
  const m=document.getElementById("bp-info");if(m)m.textContent="Tap a trait";
  activeTrait=null;document.querySelectorAll(".trow").forEach(r=>r.classList.remove("active"));
}
window.toggleDrawer=function(){drawerOpen=!drawerOpen;document.getElementById("drawer").classList.toggle("open",drawerOpen)};
window.toggleCodex=function(){
  codexOpen=!codexOpen;
  document.getElementById("codex-overlay").classList.toggle("open",codexOpen);
  if(codexOpen)renderCodex();
};
window.toggleMute=function(){
  voxEnabled=!voxEnabled;
  document.getElementById("mute-btn").textContent=voxEnabled?"ðŸ”Š":"ðŸ”‡";
  if(!voxEnabled&&voxMaster)voxMaster.gain.value=0;
  if(voxEnabled&&voxMaster)voxMaster.gain.value=0.15;
};
window.codexSpawn=function(key){
  if(currency<50)return;
  const entry=codex.get(key);
  if(!entry)return;
  currency-=50;updCurrency();
  const yRange=H*0.75;
  const c=createCreature(W/2-60+Math.random()*120,H*0.15+Math.random()*yRange*0.6,[...entry.genome]);
  creatures.push(c);viewId=c.id;
  codexOpen=false;document.getElementById("codex-overlay").classList.remove("open");
  updUI();
  floatTexts.push({x:c.x,y:c.y-20,text:"-â—¯50",age:0,hue:40});
};
const TAG_COLORS={
  tiny:"#6be",small:"#6be",medium:"#6be",large:"#6be",massive:"#6be",
  smooth:"#a8e",wavy:"#a8e",scalloped:"#a8e",jagged:"#a8e",ruffled:"#a8e",
  gelatinous:"#a8e",rigid:"#a8e",
  red:"#e66",orange:"#e96",gold:"#ec6",yellow:"#ee6",green:"#6e8",
  teal:"#6eb",blue:"#6be",indigo:"#88e",violet:"#b6e",magenta:"#e6b",crimson:"#e66",
  pale:"#ccc",vivid:"#fff",dark:"#888",bright:"#ff8","two-tone":"#eb8",
  dim:"#556","soft-glow":"#8ab","bright-glow":"#be8",blazing:"#fe8",
  "few-tentacles":"#ea8","moderate-tentacles":"#ea8","many-tentacles":"#ea8",
  "short-tentacles":"#ea8","medium-tentacles":"#ea8","long-tentacles":"#ea8",
  "thin-tentacles":"#ea8","thick-tentacles":"#ea8",
  undulating:"#c8e",swaying:"#c8e",
  sluggish:"#8a6",leisurely:"#8c6",active:"#8e6",hyperactive:"#ae6",
  "mandala-organelles":"#6ea","celtic-organelles":"#6ea","floral-organelles":"#6ea","spiral-organelles":"#6ea",
  "few-organelles":"#6ea","dense-organelles":"#6ea","large-organelles":"#6ea","tiny-organelles":"#6ea",
  "thick-membrane":"#a8b","thin-membrane":"#a8b",
  "fast-grower":"#eb6","slow-grower":"#eb6",
  floaty:"#8be",snappy:"#8be",
  "deep-voice":"#c8a","mid-voice":"#c8a","high-voice":"#c8a","soprano-voice":"#c8a",
  "pure-tone":"#c8a","rich-tone":"#c8a",
};
function tagPillHTML(tag){
  const tc=TAG_COLORS[tag]||"#7ab";
  return`<span class="ptag" style="color:${tc};border-color:${tc}44;background:${tc}18">${tag}</span>`;
}
function renderCodexPreview(cvs,genome){
  const pw=180,ph=220; // 2x for retina (90Ã—110 CSS px)
  cvs.width=pw;cvs.height=ph;
  const pCtx=cvs.getContext("2d");
  pCtx.scale(2,2);
  const bg=pCtx.createRadialGradient(45,50,8,45,50,55);
  bg.addColorStop(0,"#081828");bg.addColorStop(1,"#040a14");
  pCtx.fillStyle=bg;pCtx.fillRect(0,0,90,110);
  const tmpC=createCreature(45,42,[...genome]);
  tmpC.maturity=1.0;tmpC.age=999;
  for(const tr of tmpC.trails){
    for(let j=1;j<tr.points.length;j++){
      const p=tr.points[j],p0=tr.points[0];
      p.x=p0.x+(p.x-p0.x)*1;p.y=p0.y+(p.y-p0.y)*1;
      p.px=p.x;p.py=p.y;
    }
  }
  const origCtx=ctx;
  ctx=pCtx;
  drawCreature(tmpC,"none");
  ctx=origCtx;
}

function speciesRelations(key){
  const parts=key.split("|");
  const related=[];
  for(const[k2,entry2] of codex){
    if(k2===key)continue;
    const p2=k2.split("|");
    let shared=0;
    for(let i=0;i<5;i++) if(parts[i]===p2[i]) shared++;
    if(shared>=3) related.push({key:k2,name:entry2.name,shared});
  }
  related.sort((a,b)=>b.shared-a.shared);
  return related;
}

window.codexRename=function(key){
  const entry=codex.get(key);
  if(!entry)return;
  const cards=document.querySelectorAll(".codex-card");
  let card=null;
  for(const c of cards){if(c.dataset.codexKey===key){card=c;break}}
  if(!card)return;
  const nameSpan=card.querySelector(".cc-name");
  if(!nameSpan)return;
  const old=entry.name||"";
  nameSpan.innerHTML=`<input type="text" class="cc-rename-input" value="${old.replace(/"/g,'&quot;')}" maxlength="30" style="background:rgba(20,35,55,0.8);border:1px solid rgba(200,160,60,0.4);border-radius:3px;padding:2px 6px;color:#ec8;font-family:inherit;font-size:11px;font-weight:600;width:140px;outline:none">`;
  const inp=nameSpan.querySelector("input");
  inp.focus();inp.select();
  function commit(){
    const val=inp.value.trim();
    entry.name=val||autoName(key);
    renderCodex();
  }
  inp.onkeydown=function(e){if(e.key==="Enter")commit();if(e.key==="Escape")renderCodex()};
  inp.onblur=commit;
};

window.codexScrollTo=function(key){
  const cards=document.querySelectorAll(".codex-card");
  let card=null;
  for(const c of cards){if(c.dataset.codexKey===key){card=c;break}}
  if(card){
    card.scrollIntoView({behavior:"smooth",block:"center"});
    card.style.borderColor="rgba(200,160,60,0.5)";
    setTimeout(()=>{card.style.borderColor=""},1200);
  }
};

function renderCodex(){
  const body=document.getElementById("codex-body");
  const total=codex.size;
  document.getElementById("codex-total").textContent="â€” "+total+" species discovered";
  document.getElementById("codex-count").textContent=total;
  if(total===0){
    body.innerHTML='<div class="codex-empty">No species discovered yet.<br>LioLumes are cataloged when they reach maturity.</div>';
    return;
  }
  const entries=[...codex.entries()].sort((a,b)=>b[1].firstSeen-a[1].firstSeen);
  let html="";
  const now=Date.now();
  for(const[key,entry]of entries){
    const isNew=(now-entry.firstSeen)<15000;
    const canAfford=currency>=50;
    const rels=speciesRelations(key);
    const ek=key.replace(/'/g,"\\'");
    let relHtml="";
    if(rels.length>0){
      relHtml=`<div class="cc-rels"><span style="font-size:7px;color:#5a7a8a;letter-spacing:.5px">RELATED SPECIES</span><br>`;
      for(const r of rels){
        const axes=r.shared;
        const dots="â—".repeat(axes)+"â—‹".repeat(5-axes);
        relHtml+=`<span class="cc-rel-link" onclick="codexScrollTo('${r.key.replace(/'/g,"\\'")}')" style="font-style:italic">${r.name||'Unnamed'}</span> <span style="font-size:6px;color:#4a6a7a">${dots}</span> `;
      }
      relHtml+=`</div>`;
    }
    html+=`<div class="codex-card" data-codex-key="${key.replace(/"/g,'&quot;')}" data-genome="${entry.genome.join('')}">
      <div class="cc-body">
        <div class="cc-preview"><canvas></canvas></div>
        <div class="cc-detail">
          <div style="display:flex;align-items:baseline;margin-bottom:3px;flex-wrap:wrap;gap:3px">
            <span class="cc-name" style="font-size:11px;color:#ec8;font-weight:600;font-style:italic">${entry.name||'Unnamed'}</span>
            <button class="cc-rename" onclick="codexRename('${ek}')">âœŽ</button>
            ${isNew?'<span class="cc-new">NEW</span>':''}
          </div>
          <div class="cc-prose">${entry.prose}</div>
          <div class="cc-tags">${entry.tags.map(tagPillHTML).join("")}</div>
          ${relHtml}
          <div class="cc-meta">
            <span class="cc-stat">Seen ${entry.count}Ã— Â· ${fmtAge((now-entry.firstSeen)/1000)} ago</span>
            <button class="cc-spawn" onclick="codexSpawn('${ek}')" ${canAfford?"":"disabled"}>SPAWN â—¯50</button>
          </div>
        </div>
      </div>
    </div>`;
  }
  body.innerHTML=html;

  // Render previews on hover (lazy)
  const cards=body.querySelectorAll(".codex-card");
  cards.forEach(card=>{
    const cvs=card.querySelector("canvas");
    const gStr=card.getAttribute("data-genome");
    if(!cvs||!gStr)return;
    const genome=[...gStr];
    let rendered=false;
    card.addEventListener("mouseenter",()=>{
      if(!rendered){rendered=true;renderCodexPreview(cvs,genome)}
    });
    // Also render on touch for mobile
    card.addEventListener("touchstart",()=>{
      if(!rendered){rendered=true;renderCodexPreview(cvs,genome)}
    },{passive:true});
  });
}
window.spawn=function(){if(currency<15)return;currency-=15;updCurrency();const yRange=H*0.75;const c=createCreature(W/2-60+Math.random()*120,H*0.15+Math.random()*yRange*0.6);floatTexts.push({x:c.x,y:c.y-20,text:"-â—¯15",age:0,hue:0});creatures.push(c);viewId=c.id;updUI()};
window.breed=function(){
  const p1=creatures.find(c=>c.id===parent1Id),p2=creatures.find(c=>c.id===parent2Id);
  if(!p1||!p2)return;
  if(currency<10)return;
  currency-=10;updCurrency();
  generation++;
  const[g1]=crossover(p1.genome,p2.genome);
  const mx=(p1.x+p2.x)/2,my=(p1.y+p2.y)/2;
  floatTexts.push({x:mx,y:my-20,text:"-â—¯10",age:0,hue:0});
  const cx=Math.max(60,Math.min(W-60,mx-20+Math.random()*40));
  const cy=Math.max(60,Math.min(H*0.82,my-20+Math.random()*40));
  const child=createCreature(cx,cy,g1);
  child.gen=generation;
  creatures.push(child);parent1Id=null;parent2Id=null;viewId=child.id;updUI();
};
window.clearAll=function(){creatures=[];parent1Id=parent2Id=viewId=null;generation=0;bubbles=[];floatTexts=[];hearts=[];growZones=[];placingGrow=false;updUI()};
window.sell=function(){
  if(!viewId)return;
  const sel=creatures.find(c=>c.id===viewId);
  if(sel&&(sel.maturity||0)>=0.95){currency+=10;updCurrency();floatTexts.push({x:sel.x,y:sel.y,text:"+â—¯10",age:0,hue:sel.traits.hue})}
  const sid=viewId;
  creatures=creatures.filter(c=>c.id!==sid);
  if(parent1Id===sid)parent1Id=null;
  if(parent2Id===sid)parent2Id=null;
  viewId=null;
  updUI();
};
function toggleBP(cid,idx){
  const c=creatures.find(c=>c.id===cid);
  if(!c)return;
  // Cycle base: Aâ†’Tâ†’Câ†’Gâ†’A
  const order=["A","T","C","G"];
  const cur=order.indexOf(c.genome[idx]);
  c.genome[idx]=order[(cur+1)%4];
  // Rebuild traits, hull, and trails from new genome
  rebuildCreature(c);
  updUI();
}
function rebuildCreature(c){
  const t=decode(c.genome);
  c.traits=t;
  c.staticHull=buildStaticHull(t,c.genome);
  // Rebuild trails with new params, keeping creature position
  const nT=t.trails;
  const nProf=c.staticHull.length;
  const fullHull=buildLumeShape(t,c.staticHull,0);
  const hN=fullHull.length;
  const botIdx=nProf-1;
  const botPt=fullHull[botIdx];
  const rightArc=[{x:botPt.x,y:botPt.y,d:0,hi:botIdx}];
  let rDist=0;
  for(let k=botIdx-1;k>=1;k--){
    const prev=rightArc[rightArc.length-1];
    const nd=fullHull[k];
    rDist+=Math.hypot(nd.x-prev.x,nd.y-prev.y);
    if(nd.y<botPt.y-Math.abs(botPt.y)*0.8-t.maxReach*0.3)break;
    rightArc.push({x:nd.x,y:nd.y,d:rDist,hi:k});
  }
  const leftArc=[{x:botPt.x,y:botPt.y,d:0,hi:botIdx}];
  let lDist=0;
  for(let k=botIdx+1;k<hN;k++){
    const prev=leftArc[leftArc.length-1];
    const nd=fullHull[k];
    lDist+=Math.hypot(nd.x-prev.x,nd.y-prev.y);
    if(nd.y<botPt.y-Math.abs(botPt.y)*0.8-t.maxReach*0.3)break;
    leftArc.push({x:nd.x,y:nd.y,d:lDist,hi:k});
  }
  const arcLen=Math.min(rDist,lDist)||1;
  function interpArc(arc,d){
    for(let k=1;k<arc.length;k++){
      if(arc[k].d>=d){
        const f=(d-arc[k-1].d)/(arc[k].d-arc[k-1].d||1);
        return{x:arc[k-1].x+(arc[k].x-arc[k-1].x)*f,y:arc[k-1].y+(arc[k].y-arc[k-1].y)*f,hi:arc[k].hi,ht:f};
      }
    }
    const last=arc[arc.length-1];return{x:last.x,y:last.y,hi:last.hi,ht:1};
  }
  function findHullEdge(px,py){
    let best=Infinity,bhi=0,bht=0;
    for(let k=0;k<hN;k++){
      const a2=fullHull[k],b2=fullHull[(k+1)%hN];
      const ex=b2.x-a2.x,ey=b2.y-a2.y,el2=ex*ex+ey*ey||1;
      const tt=Math.max(0,Math.min(1,(((px-a2.x)*ex+(py-a2.y)*ey)/el2)));
      const cx=a2.x+ex*tt,cy=a2.y+ey*tt;
      const d2=(px-cx)**2+(py-cy)**2;
      if(d2<best){best=d2;bhi=k;bht=tt}
    }
    return{hi:bhi,ht:bht};
  }
  const attachPts=[];
  if(nT%2===1){attachPts.push({lx:botPt.x,ly:botPt.y,...findHullEdge(botPt.x,botPt.y)})}
  const nPairs=Math.floor(nT/2);
  for(let p=0;p<nPairs;p++){
    const frac=(p+1)/(nPairs+0.5);
    const d=frac*arcLen;
    const rp=interpArc(rightArc,d),lp=interpArc(leftArc,d);
    attachPts.push({lx:rp.x,ly:rp.y,...findHullEdge(rp.x,rp.y)});
    attachPts.push({lx:lp.x,ly:lp.y,...findHullEdge(lp.x,lp.y)});
  }
  const trails=[];
  for(let i=0;i<nT;i++){
    const ap=attachPts[i];
    const tp=trailParams(t,c.genome,i,nT);
    const pts=[];
    for(let j=0;j<tp.nodes;j++){
      pts.push(vpt(c.x+ap.lx,c.y+ap.ly+j*tp.segLen));
    }
    trails.push({lx:ap.lx,ly:ap.ly,hullIdx:ap.hi,hullT:ap.ht,segLen:tp.segLen,trailGroup:i,points:pts});
  }
  c.trails=trails;
  c.organelles=generateOrganelles(t,c.genome);
}

function cPos(e){const r=canvas.getBoundingClientRect();if(e.touches)return{x:e.touches[0].clientX-r.left,y:e.touches[0].clientY-r.top};return{x:e.clientX-r.left,y:e.clientY-r.top}}
canvas.addEventListener("mousedown",e=>{startDrag(cPos(e).x,cPos(e).y)});
canvas.addEventListener("mousemove",e=>{const p=cPos(e);if(dragId)moveDrag(p.x,p.y);if(placingGrow){growPreview={x:p.x,y:p.y}}const bi=hitBubble(p.x,p.y);if(bi>=0)popBubble(bi)});
canvas.addEventListener("mouseup",e=>{endDrag(cPos(e).x,cPos(e).y)});
canvas.addEventListener("mouseleave",()=>{if(dragId){canvas.style.cursor="crosshair";dragId=null}growPreview=null});
document.addEventListener("keydown",e=>{if(e.key==="Escape"){if(codexOpen){codexOpen=false;document.getElementById("codex-overlay").classList.remove("open")}else if(placingGrow){placingGrow=false;canvas.style.cursor="crosshair";growPreview=null}}});
let touchPos=null;
canvas.addEventListener("touchstart",e=>{e.preventDefault();touchPos=cPos(e);if(placingGrow){growPreview={x:touchPos.x,y:touchPos.y}}startDrag(touchPos.x,touchPos.y)},{passive:false});
canvas.addEventListener("touchmove",e=>{e.preventDefault();touchPos=cPos(e);if(dragId){moveDrag(touchPos.x,touchPos.y)}if(placingGrow){growPreview={x:touchPos.x,y:touchPos.y}}const bi=hitBubble(touchPos.x,touchPos.y);if(bi>=0)popBubble(bi)},{passive:false});
canvas.addEventListener("touchend",e=>{e.preventDefault();if(touchPos)endDrag(touchPos.x,touchPos.y);touchPos=null},{passive:false});

function drawTitle(now){
  const elapsed=(now-titleStart)/1000;
  if(elapsed>30) return;
  const alpha=elapsed<20?1:1-(elapsed-20)/10;
  if(alpha<=0) return;
  const t=elapsed*0.8;
  const fontSize=Math.max(Math.min(W*0.22,H*0.18),40);
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.font=`300 ${fontSize}px "Nunito","Quicksand","Comfortaa","Varela Round","Rubik",system-ui,sans-serif`;
  ctx.textAlign="center";ctx.textBaseline="middle";
  ctx.lineCap="round";ctx.lineJoin="round";
  const cx=W/2, cy=H*0.42;
  const layers=5;
  for(let l=0;l<layers;l++){
    const phase=t*1.2+l*0.7;
    const wobX=Math.sin(phase*1.1+l)*1.5+Math.sin(phase*0.7-l*0.5)*1.0;
    const wobY=Math.cos(phase*0.9+l*1.3)*1.1+Math.cos(phase*1.5+l)*0.7;
    const hue=190+l*12+Math.sin(t+l)*8;
    const lit=55+l*5;
    const a2=alpha*(0.1+l*0.03);
    ctx.strokeStyle=`hsla(${hue},45%,${lit}%,${a2})`;
    ctx.lineWidth=2.2-l*0.2;
    ctx.strokeText("LioLume",cx+wobX,cy+wobY);
  }
  const coreWobX=Math.sin(t*0.6)*0.6;
  const coreWobY=Math.cos(t*0.8)*0.5;
  ctx.strokeStyle=`hsla(195,50%,75%,${alpha*0.3})`;
  ctx.lineWidth=1.0;
  ctx.strokeText("LioLume",cx+coreWobX,cy+coreWobY);
  ctx.shadowColor=`hsla(200,60%,70%,${alpha*0.12})`;
  ctx.shadowBlur=fontSize*0.12;
  ctx.strokeStyle=`hsla(200,40%,80%,${alpha*0.1})`;
  ctx.lineWidth=0.6;
  ctx.strokeText("LioLume",cx,cy);
  ctx.shadowBlur=0;
  ctx.restore();
}

let lastTime=performance.now(),ageTickCounter=0;
const titleStart=performance.now();
function frame(now){
  const dt=Math.min((now-lastTime)/1000,.05);lastTime=now;
  ctx.save();
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,"#040a14");grad.addColorStop(.4,"#081828");grad.addColorStop(1,"#061020");
  ctx.fillStyle=grad;ctx.fillRect(0,0,W,H);
  const vg=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*.2,W/2,H/2,Math.max(W,H)*.72);
  vg.addColorStop(0,"rgba(0,0,0,0)");vg.addColorStop(1,"rgba(0,0,0,0.45)");
  ctx.fillStyle=vg;ctx.fillRect(0,0,W,H);
  const tm=Date.now()*.0003;ctx.globalAlpha=.018;
  for(let i=0;i<5;i++){ctx.beginPath();ctx.arc(W*.3+Math.sin(tm+i*1.3)*W*.3,H*.3+Math.cos(tm*.7+i*.9)*H*.3,60+Math.sin(tm+i)*30,0,Math.PI*2);ctx.fillStyle=`hsla(${190+i*15},50%,70%,1)`;ctx.fill()}
  ctx.globalAlpha=1;drawSubstrate(now);drawP();
  // Jelly title behind creatures
  drawTitle(now);
  // Grow zones (update only, draw later on top)
  updateGrowZones(dt);
  // Update all creatures
  for(const c of creatures) updateCreature(c,dt);
  // Soft body collisions â€” multiple iterations for stability
  for(let iter=0;iter<3;iter++){
    for(let i=0;i<creatures.length;i++){
      for(let j=i+1;j<creatures.length;j++){
        softCollide(creatures[i],creatures[j]);
      }
    }
  }
  // Re-clamp after collisions
  for(const c of creatures){
    if(c.id===dragId) continue;
    const pad=15+c.traits.maxReach*0.5;
    const bpad=H*0.13+c.traits.maxReach*0.5;
    c.x=Math.max(pad,Math.min(W-pad,c.x));
    c.y=Math.max(pad,Math.min(H-bpad,c.y));
  }
  // Draw all creatures
  for(const c of creatures) drawCreature(c,getSelType(c));
  // Grow zones (drawn on top of creatures)
  drawGrowZones();
  // Bubbles
  updateBubbles(dt);
  drawBubbles();
  // Auto-breeding
  tryAutoBreed(dt);
  updateHearts(dt);
  drawHearts();
  updateFloatTexts(dt);
  drawFloatTexts();
  // Grow zone placement preview
  if(placingGrow&&growPreview){
    ctx.beginPath();ctx.arc(growPreview.x,growPreview.y,70,0,Math.PI*2);
    ctx.strokeStyle="rgba(80,240,140,0.6)";ctx.lineWidth=2.5;ctx.setLineDash([6,4]);ctx.stroke();ctx.setLineDash([]);
    const pg=ctx.createRadialGradient(growPreview.x,growPreview.y,0,growPreview.x,growPreview.y,70);
    pg.addColorStop(0,"rgba(80,240,140,0.15)");pg.addColorStop(1,"rgba(80,240,140,0)");
    ctx.fillStyle=pg;ctx.fill();
    ctx.font="bold 11px 'JetBrains Mono',monospace";ctx.textAlign="center";
    ctx.fillStyle="rgba(80,240,140,0.7)";ctx.fillText("TAP TO PLACE",growPreview.x,growPreview.y+4);
  }
  // Live-update selected creature's age display
  if(++ageTickCounter%30===0){
    document.getElementById("codex-count").textContent=codex.size;
    if(viewId){
    const sel=creatures.find(c2=>c2.id===viewId);
    if(sel){
      const si=document.getElementById("sel-info");
      const sm=(sel.maturity||0)>=0.95;
      if(si)si.innerHTML=
        (sel.id===parent1Id?`<span style="color:#5ae;font-weight:600">â— P1</span> `:
         sel.id===parent2Id?`<span style="color:#ea5;font-weight:600">â— P2</span> `:"")+
        `<span style="color:#4a6a8a">Gen ${sel.gen||0}</span>`+
        ` <span style="color:#8a7a4a">${(sel.maturity||0)<0.1?"ðŸ¥š Egg":(sel.maturity||0)<0.3?"ðŸ«§ Larva":(sel.maturity||0)<0.6?"â— Juvenile":(sel.maturity||0)<0.95?"â—‘ Adolescent":"â— Mature"}</span>`+
        ` <span style="color:#5a6a5a;font-size:8px">${fmtAge(sel.age||0)}</span>`+
        (!sm&&sel.id!==parent1Id&&sel.id!==parent2Id?` <span style="color:#6a4a4a;font-size:7px">too young to breed</span>`:"");
      // Auto-promote to parent when mature
      if(sm&&sel.id===viewId&&sel.id!==parent1Id&&sel.id!==parent2Id){
        if(!parent1Id){parent1Id=sel.id;updUI()}
        else if(!parent2Id&&sel.id!==parent1Id){parent2Id=sel.id;updUI()}
      }
    }
    } // end if(viewId)
  } // end ageTickCounter
  // Draw helix in panel
  drawHelixFrame(dt);
  ctx.restore();requestAnimationFrame(frame);
}
window.addEventListener("resize",()=>{resize();initP();initSubstrate();if(helixGenome)initHelixCanvas()});
resize();initP();initSubstrate();
const first=createCreature(W/2-40,H*0.4);first.isFirst=true;creatures.push(first);
const second=createCreature(W/2+40,H*0.35);second.isFirst=true;creatures.push(second);
viewId=first.id;updUI();
requestAnimationFrame(frame);
</script>
</body>
</html>
